#!/usr/bin/env bash
# trimtab secrets — scan for committed secrets and audit .env hygiene
# Usage: trimtab secrets [scan|audit|fix]
set -euo pipefail

source "$(dirname "$0")/trimtab-common.sh"

# ============================================================
# SCAN — find committed secrets across all projects
# ============================================================
cmd_scan() {
  section "Secret Scan (tracked files)"

  local total_hits=0
  local projects_with_hits=0

  # Patterns: name|regex
  local patterns=(
    "Anthropic API key|sk-ant-api"
    "OpenAI API key|sk-[a-zA-Z0-9]{20,}"
    "GitHub PAT|ghp_[a-zA-Z0-9]{36}"
    "Private key|-----BEGIN.*PRIVATE KEY-----"
    "AWS access key|AKIA[0-9A-Z]{16}"
    "Slack token|xox[bp]-[a-zA-Z0-9-]+"
    "Generic secret assignment|(_KEY|_SECRET|_TOKEN)=['\"]?[A-Za-z0-9/+=]{20,}"
  )

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir/.git" ]] || continue
    local proj
    proj=$(basename "$proj_dir")
    local proj_hits=0
    local proj_output=""

    for pattern_entry in "${patterns[@]}"; do
      local label="${pattern_entry%%|*}"
      local regex="${pattern_entry#*|}"

      local matches
      matches=$(git -C "$proj_dir" grep -n -E "$regex" -- ':(exclude)*.lock' ':(exclude)node_modules' ':(exclude)_build' ':(exclude)deps' 2>/dev/null || true)
      [[ -z "$matches" ]] && continue

      # Filter out common false positives (comments, docs, test fixtures)
      local filtered=""
      while IFS= read -r line; do
        # Skip if the line is in a comment, README, changelog, or test fixture
        local filepath="${line%%:*}"
        case "$filepath" in
          *.md|*/CHANGELOG*|*/README*) continue ;;
        esac
        filtered+="$line"$'\n'
      done <<< "$matches"
      [[ -z "$filtered" ]] && continue

      local count
      count=$(echo -n "$filtered" | grep -c .)
      proj_hits=$((proj_hits + count))
      proj_output+="    ${Y}●${N} ${label} (${count} hit(s))"$'\n'
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        proj_output+="      ${D}${line}${N}"$'\n'
      done <<< "$filtered"
    done

    if (( proj_hits > 0 )); then
      printf "\n  ${B}%s${N} ${R}(%d)${N}\n" "$proj" "$proj_hits"
      printf '%s' "$proj_output"
      total_hits=$((total_hits + proj_hits))
      projects_with_hits=$((projects_with_hits + 1))
    fi
  done

  section "Summary"
  if (( total_hits == 0 )); then
    printf "  ${G}No committed secrets found.${N}\n"
  else
    printf "  ${R}%d potential secret(s)${N} in %d project(s)\n" "$total_hits" "$projects_with_hits"
    printf "  ${D}Review each hit — some may be false positives (test data, docs).${N}\n"
    printf "  ${D}To remove from history: trimtab secrets fix or git filter-repo${N}\n"
  fi
}

# ============================================================
# AUDIT — show .env hygiene across projects
# ============================================================
cmd_audit() {
  section ".env Hygiene"
  printf "  ${D}%-22s %-10s %-12s %-10s${N}\n" "PROJECT" "HAS .env" "IN .gitignore" "TRACKED"
  printf "  ${D}%-22s %-10s %-12s %-10s${N}\n" "───────" "────────" "────────────" "───────"

  local issues=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir/.git" ]] || continue
    local proj
    proj=$(basename "$proj_dir")

    local has_env="  ${D}·${N} "
    local in_gitignore="  ${D}·${N}  "
    local is_tracked="  ${D}·${N} "
    local row_color=""

    # Check for .env file
    if [[ -f "$proj_dir/.env" ]]; then
      has_env="${G}yes${N}   "

      # Check .gitignore
      if [[ -f "$proj_dir/.gitignore" ]] && grep -qE '^\s*\.env\s*$|^\s*\.env\s*#' "$proj_dir/.gitignore" 2>/dev/null; then
        in_gitignore="${G}yes${N}     "
      else
        in_gitignore="${R}NO${N}      "
        issues=$((issues + 1))
      fi

      # Check if tracked by git
      if git -C "$proj_dir" ls-files --error-unmatch .env &>/dev/null; then
        is_tracked="${R}YES${N}  "
        issues=$((issues + 1))
      else
        is_tracked="${G}no${N}   "
      fi
    fi

    printf "  %-22s %s %s %s\n" "$proj" "$has_env" "$in_gitignore" "$is_tracked"
  done

  section "Summary"
  if (( issues == 0 )); then
    printf "  ${G}All .env files are properly gitignored and untracked.${N}\n"
  else
    printf "  ${R}%d issue(s)${N} — fix with: ${B}trimtab secrets fix${N}\n" "$issues"
  fi
}

# ============================================================
# FIX — add .env to .gitignore and untrack if needed
# ============================================================
cmd_fix() {
  section "Fixing .env Hygiene"

  local fixed=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir/.git" ]] || continue
    local proj
    proj=$(basename "$proj_dir")

    [[ -f "$proj_dir/.env" ]] || continue

    local needs_fix=false

    # Add to .gitignore if missing
    if [[ -f "$proj_dir/.gitignore" ]]; then
      if ! grep -qE '^\s*\.env\s*$|^\s*\.env\s*#' "$proj_dir/.gitignore" 2>/dev/null; then
        printf '\n# Environment\n.env\n' >> "$proj_dir/.gitignore"
        ok "$proj: added .env to .gitignore"
        needs_fix=true
      fi
    else
      printf '# Environment\n.env\n' > "$proj_dir/.gitignore"
      ok "$proj: created .gitignore with .env"
      needs_fix=true
    fi

    # Untrack if tracked
    if git -C "$proj_dir" ls-files --error-unmatch .env &>/dev/null; then
      git -C "$proj_dir" rm --cached .env >/dev/null 2>&1
      ok "$proj: untracked .env (git rm --cached)"
      needs_fix=true
    fi

    if $needs_fix; then
      fixed=$((fixed + 1))
    fi
  done

  section "Summary"
  if (( fixed == 0 )); then
    printf "  ${G}Nothing to fix — all .env files are clean.${N}\n"
  else
    printf "  ${G}Fixed %d project(s).${N}\n" "$fixed"
    printf "  ${D}Remember to commit the .gitignore changes.${N}\n"
  fi
}

# ============================================================
# DISPATCH
# ============================================================
subcmd="${1:-audit}"
shift 2>/dev/null || true

case "$subcmd" in
  scan)           cmd_scan "$@" ;;
  audit)          cmd_audit "$@" ;;
  fix)            cmd_fix "$@" ;;
  help|-h|--help)
    cat <<EOF
trimtab secrets — scan for committed secrets and audit .env hygiene

Usage: trimtab secrets [command]

Commands:
  scan    Scan all projects for committed secrets (API keys, tokens, private keys)
  audit   Show .env hygiene table: has .env, in .gitignore, tracked by git (default)
  fix     Add .env to .gitignore and untrack across all projects

Examples:
  trimtab secrets             # show .env hygiene table
  trimtab secrets scan        # scan for committed secrets
  trimtab secrets fix         # fix .env hygiene issues
EOF
    ;;
  *)
    err "unknown subcommand '$subcmd'. Run 'trimtab secrets help' for usage."
    ;;
esac
