#!/usr/bin/env bash
# trimtab agent — manage Claude Code sessions via tmux (local + remote)
# Usage: trimtab agent [list|spawn|peek|send|broadcast] [args...]
set -euo pipefail

source "$(dirname "$0")/trimtab-portable.sh"
source "$(dirname "$0")/trimtab-common.sh"
AGENT_SESSION="agents"
AGENT_IMAGE="trimtab-agent"
CONTAINER_PREFIX="agent-"

# --- Remote hosts ---
# Each entry: "alias|ssh_host|remote_projects_dir"
HOSTS_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/trimtab/hosts"
REMOTE_HOSTS=()

load_remote_hosts() {
  if [[ -f "$HOSTS_FILE" ]]; then
    while IFS= read -r line; do
      [[ -z "$line" || "$line" == \#* ]] && continue
      REMOTE_HOSTS+=("$line")
    done < "$HOSTS_FILE"
  fi
}
load_remote_hosts

# Parse a host entry: "alias|ssh_host|remote_projects_dir"
parse_host() {
  local entry="$1"
  HOST_ALIAS="${entry%%|*}"
  local rest="${entry#*|}"
  HOST_SSH="${rest%%|*}"
  HOST_PROJECTS="${rest#*|}"
}

# Run a command on a remote host via SSH (timeout 5s for discovery)
remote_cmd() {
  local ssh_host="$1"; shift
  ssh -o ConnectTimeout=3 -o BatchMode=yes "$ssh_host" "$@" 2>/dev/null
}


# Build the podman run command for a given project
# Usage: podman_run_cmd <home_dir> <projects_dir> <project> [selinux] [name_override]
podman_run_cmd() {
  local home="$1" projects="$2" project="$3" selinux="${4:-0}" name="${5:-${CONTAINER_PREFIX}${3}}"
  local vol_suffix=""
  (( selinux )) && vol_suffix=":Z"

  printf "podman run -it --rm --name %s --network host -v %s/.claude:/root/.claude%s -v %s/%s:/work%s %s -c claude" \
    "$name" \
    "$home" "$vol_suffix" \
    "$projects" "$project" "$vol_suffix" \
    "$AGENT_IMAGE"
}

# Detect if host has SELinux enforcing (checks actual state, not distro)
detect_selinux() {
  if command -v getenforce &>/dev/null && [[ "$(getenforce 2>/dev/null)" == "Enforcing" ]]; then
    echo 1
  else
    echo 0
  fi
}

detect_selinux_remote() {
  local ssh_host="$1"
  remote_cmd "$ssh_host" 'command -v getenforce >/dev/null 2>&1 && [ "$(getenforce 2>/dev/null)" = "Enforcing" ] && echo 1 || echo 0' || echo 0
}

# ============================================================
# DISCOVERY
# ============================================================

# Discover all Claude sessions (local + remote). Sets parallel arrays:
#   AGENT_PROJECTS[], AGENT_TARGETS[], AGENT_ELAPSED[], AGENT_STATUSES[], AGENT_HOSTS[]
discover_agents() {
  AGENT_PROJECTS=()
  AGENT_TARGETS=()
  AGENT_ELAPSED=()
  AGENT_STATUSES=()
  AGENT_HOSTS=()

  # --- Local discovery ---
  discover_local

  # --- Remote discovery ---
  for entry in "${REMOTE_HOSTS[@]}"; do
    parse_host "$entry"
    discover_remote "$HOST_ALIAS" "$HOST_SSH"
  done
}

discover_local() {
  declare -A seen_projects=()

  # Pass 1: agent containers (podman)
  while IFS='|' read -r cname running_for; do
    [[ -z "$cname" ]] && continue
    local project="${cname#"$CONTAINER_PREFIX"}"
    seen_projects["$project"]=1

    # Find matching tmux target by window name
    local target="—"
    if tmux list-sessions &>/dev/null; then
      target=$(tmux list-windows -a -F "#{session_name}:#{window_index}|#{window_name}" 2>/dev/null \
        | grep "|${project}$" | head -1 | cut -d'|' -f1) || target="—"
      [[ -z "$target" ]] && target="—"
    fi

    local session_name="${target%%:*}"
    local status="container"
    [[ "$target" != "—" && "$session_name" != "$AGENT_SESSION" ]] && status="container (other)"

    AGENT_PROJECTS+=("$project")
    AGENT_TARGETS+=("$target")
    AGENT_ELAPSED+=("$running_for")
    AGENT_STATUSES+=("$status")
    AGENT_HOSTS+=("local")
  done < <(podman ps --filter "name=${CONTAINER_PREFIX}" --format '{{.Names}}|{{.RunningFor}}' 2>/dev/null || true)

  # Pass 2: bare claude processes in tmux panes (non-containerized)
  if tmux list-sessions &>/dev/null; then
    while IFS='|' read -r target pane_pid cmd path wname; do
      [[ -z "$pane_pid" ]] && continue
      local claude_pid=""

      if [[ "$cmd" == "claude" ]]; then
        claude_pid="$pane_pid"
      else
        claude_pid=$(pgrep -P "$pane_pid" -x claude 2>/dev/null | head -1) || true
      fi

      [[ -z "$claude_pid" ]] && continue

      local project
      project=$(basename "$path")
      # Skip if already found as a container
      [[ -n "${seen_projects[$project]:-}" ]] && continue
      seen_projects["$project"]=1

      local elapsed
      elapsed=$(ps -o etime= -p "$claude_pid" 2>/dev/null | xargs) || elapsed="?"

      local session_name="${target%%:*}"
      local status="tmux"
      [[ "$session_name" != "$AGENT_SESSION" ]] && status="tmux (other)"

      AGENT_PROJECTS+=("$project")
      AGENT_TARGETS+=("$target")
      AGENT_ELAPSED+=("$elapsed")
      AGENT_STATUSES+=("$status")
      AGENT_HOSTS+=("local")
    done < <(tmux list-panes -a -F "#{session_name}:#{window_index}.#{pane_index}|#{pane_pid}|#{pane_current_command}|#{pane_current_path}|#{window_name}" 2>/dev/null || true)
  fi

  # Pass 3: orphan bare claude PIDs (not in tmux, not in containers)
  while IFS= read -r pid; do
    [[ -z "$pid" ]] && continue

    local cwd project elapsed
    cwd=$(_proc_cwd "$pid") || continue
    project=$(basename "$cwd")
    [[ -n "${seen_projects[$project]:-}" ]] && continue

    elapsed=$(ps -o etime= -p "$pid" 2>/dev/null | xargs) || elapsed="?"

    AGENT_PROJECTS+=("$project")
    AGENT_TARGETS+=("—")
    AGENT_ELAPSED+=("$elapsed")
    AGENT_STATUSES+=("detached")
    AGENT_HOSTS+=("local")
  done < <(pgrep -x claude 2>/dev/null || true)
}

discover_remote() {
  local alias="$1" ssh_host="$2"
  local prefix="$CONTAINER_PREFIX"

  # Single SSH call: get containers + tmux panes + bare claude PIDs
  local remote_data
  remote_data=$(remote_cmd "$ssh_host" '
    # Agent containers
    podman ps --filter "name='"$prefix"'" --format "CTR|{{.Names}}|{{.RunningFor}}" 2>/dev/null

    # tmux windows (for correlating container → tmux target)
    if tmux list-sessions 2>/dev/null >&2; then
      tmux list-windows -a -F "WIN|#{session_name}:#{window_index}|#{window_name}" 2>/dev/null

      # Bare claude processes in tmux panes
      tmux list-panes -a -F "#{session_name}:#{window_index}.#{pane_index}|#{pane_pid}|#{pane_current_command}|#{pane_current_path}|#{window_name}" 2>/dev/null | while IFS="|" read -r target pane_pid cmd path wname; do
        claude_pid=""
        if [ "$cmd" = "claude" ]; then
          claude_pid="$pane_pid"
        else
          claude_pid=$(pgrep -P "$pane_pid" -x claude 2>/dev/null | head -1) || true
        fi
        [ -z "$claude_pid" ] && continue
        elapsed=$(ps -o etime= -p "$claude_pid" 2>/dev/null | xargs) || elapsed="?"
        echo "TMUX|$target|$(basename "$path")|$elapsed"
      done
    fi
    # Orphan bare PIDs
    for pid in $(pgrep -x claude 2>/dev/null); do
      cwd=$(readlink -f "/proc/$pid/cwd" 2>/dev/null) || continue
      echo "PID|$pid|$(basename "$cwd")|$(ps -o etime= -p "$pid" 2>/dev/null | xargs)"
    done
  ') || { printf "  ${D}%s: unreachable${N}\n" "$alias" >&2; return; }

  [[ -z "$remote_data" ]] && return

  # Build a map of window_name → tmux_target from WIN lines
  declare -A win_map=()
  while IFS='|' read -r type target wname; do
    [[ "$type" != "WIN" ]] && continue
    win_map["$wname"]="$target"
  done <<< "$remote_data"

  declare -A seen_projects=()

  # Pass 1: containers
  while IFS='|' read -r type cname running_for; do
    [[ "$type" != "CTR" ]] && continue
    local project="${cname#"$prefix"}"
    seen_projects["$project"]=1

    local target="${win_map[$project]:-—}"
    local session_name="${target%%:*}"
    local status="container"
    [[ "$target" != "—" && "$session_name" != "$AGENT_SESSION" ]] && status="container (other)"

    AGENT_PROJECTS+=("$project")
    AGENT_TARGETS+=("${alias}:${target}")
    AGENT_ELAPSED+=("$running_for")
    AGENT_STATUSES+=("$status")
    AGENT_HOSTS+=("$alias")
  done <<< "$remote_data"

  # Pass 2: bare tmux entries
  while IFS='|' read -r type target project elapsed; do
    [[ "$type" != "TMUX" ]] && continue
    [[ -n "${seen_projects[$project]:-}" ]] && continue
    seen_projects["$project"]=1

    local session_name="${target%%:*}"
    local status="tmux"
    [[ "$session_name" != "$AGENT_SESSION" ]] && status="tmux (other)"

    AGENT_PROJECTS+=("$project")
    AGENT_TARGETS+=("${alias}:${target}")
    AGENT_ELAPSED+=("$elapsed")
    AGENT_STATUSES+=("$status")
    AGENT_HOSTS+=("$alias")
  done <<< "$remote_data"

  # Pass 3: orphan bare PIDs
  while IFS='|' read -r type pid project elapsed; do
    [[ "$type" != "PID" ]] && continue
    [[ -n "${seen_projects[$project]:-}" ]] && continue

    AGENT_PROJECTS+=("$project")
    AGENT_TARGETS+=("—")
    AGENT_ELAPSED+=("$elapsed")
    AGENT_STATUSES+=("detached ($alias)")
    AGENT_HOSTS+=("$alias")
  done <<< "$remote_data"
}

# Resolve "host:project", "project", or direct tmux target to (host, tmux_target).
# Sets: RESOLVED_HOST, RESOLVED_TARGET, RESOLVED_SSH
resolve_target() {
  local input="$1"
  RESOLVED_HOST=""
  RESOLVED_TARGET=""
  RESOLVED_SSH=""

  # Check for "host:project" syntax (host alias followed by colon and project name)
  # Distinguish from tmux targets like "session:window.pane" by checking against known hosts
  local maybe_host="${input%%:*}"
  local maybe_rest="${input#*:}"

  for entry in "${REMOTE_HOSTS[@]}"; do
    parse_host "$entry"
    if [[ "$maybe_host" == "$HOST_ALIAS" && -n "$maybe_rest" ]]; then
      # It's host:project or host:tmux_target
      RESOLVED_HOST="$HOST_ALIAS"
      RESOLVED_SSH="$HOST_SSH"

      # If rest contains ":" it's a full tmux target (host:session:window.pane)
      if [[ "$maybe_rest" == *:* ]]; then
        RESOLVED_TARGET="$maybe_rest"
        return
      fi

      # Otherwise resolve project name on that host
      resolve_remote_project "$HOST_ALIAS" "$HOST_SSH" "$maybe_rest"
      return
    fi
  done

  # Not a remote host prefix — resolve locally
  RESOLVED_HOST="local"

  # Direct local tmux target (contains ":")
  if [[ "$input" == *:* ]]; then
    if tmux display-message -t "$input" -p "#{pane_id}" &>/dev/null; then
      RESOLVED_TARGET="$input"
      return
    fi
    err "tmux target '$input' not found"
  fi

  # Look up by project name across all discovered agents
  discover_agents
  local match_indices=()
  for i in "${!AGENT_PROJECTS[@]}"; do
    if [[ "${AGENT_PROJECTS[$i]}" == "$input" && "${AGENT_TARGETS[$i]}" != "—" ]]; then
      match_indices+=("$i")
    fi
  done

  if (( ${#match_indices[@]} == 0 )); then
    printf "${R}error:${N} no tmux agent session for '%s'\n" "$input" >&2
    if (( ${#AGENT_PROJECTS[@]} > 0 )); then
      printf "Running agents: %s\n" "$(printf '%s, ' "${AGENT_PROJECTS[@]}" | sed 's/, $//')" >&2
    fi
    exit 1
  fi

  if (( ${#match_indices[@]} == 1 )); then
    local idx="${match_indices[0]}"
    RESOLVED_HOST="${AGENT_HOSTS[$idx]}"
    RESOLVED_TARGET="${AGENT_TARGETS[$idx]}"
    # Set SSH host if remote
    if [[ "$RESOLVED_HOST" != "local" ]]; then
      for entry in "${REMOTE_HOSTS[@]}"; do
        parse_host "$entry"
        [[ "$HOST_ALIAS" == "$RESOLVED_HOST" ]] && RESOLVED_SSH="$HOST_SSH"
      done
    fi
    return
  fi

  # Multiple matches — tell user to disambiguate
  printf "${R}error:${N} multiple sessions for '%s' — disambiguate with host:project:\n" "$input" >&2
  for idx in "${match_indices[@]}"; do
    printf "  %s:%s  (%s)\n" "${AGENT_HOSTS[$idx]}" "${AGENT_PROJECTS[$idx]}" "${AGENT_TARGETS[$idx]}" >&2
  done
  exit 1
}

resolve_remote_project() {
  local alias="$1" ssh_host="$2" project="$3"

  local target
  target=$(remote_cmd "$ssh_host" "
    if tmux list-sessions 2>/dev/null >&2; then
      tmux list-panes -a -F '#{session_name}:#{window_index}.#{pane_index}|#{pane_pid}|#{pane_current_command}|#{pane_current_path}' 2>/dev/null | while IFS='|' read -r t ppid cmd path; do
        claude_pid=''
        if [ \"\$cmd\" = 'claude' ]; then
          claude_pid=\"\$ppid\"
        else
          claude_pid=\$(pgrep -P \"\$ppid\" -x claude 2>/dev/null | head -1) || true
        fi
        [ -z \"\$claude_pid\" ] && continue
        proj=\$(basename \"\$path\")
        [ \"\$proj\" = '$project' ] && echo \"\$t\" && exit 0
      done
    fi
  ") || true

  if [[ -z "$target" ]]; then
    err "no agent session for '$project' on $alias"
  fi

  RESOLVED_TARGET="$target"
}

# ============================================================
# SUBCOMMANDS
# ============================================================

cmd_list() {
  discover_agents

  section "Agent Sessions"

  if (( ${#AGENT_PROJECTS[@]} == 0 )); then
    printf "  ${D}none${N}\n"
    printf "\n  Launch one with: ${B}trimtab agent spawn <project>${N}\n"
    return
  fi

  printf "  ${D}%-22s %-24s %-12s %s${N}\n" "PROJECT" "TARGET" "ELAPSED" "STATUS"
  for i in "${!AGENT_PROJECTS[@]}"; do
    local status_color="$G"
    [[ "${AGENT_STATUSES[$i]}" == *"detached"* ]] && status_color="$Y"
    printf "  %-22s %-24s %-12s ${status_color}%s${N}\n" \
      "${AGENT_PROJECTS[$i]}" "${AGENT_TARGETS[$i]}" "${AGENT_ELAPSED[$i]}" "${AGENT_STATUSES[$i]}"
  done
}

cmd_spawn() {
  local project="" host_flag=""

  while (( $# > 0 )); do
    case "$1" in
      --on) host_flag="$2"; shift 2 ;;
      *)    project="$1"; shift ;;
    esac
  done

  [[ -z "$project" ]] && err "usage: trimtab agent spawn [--on <host>] <project>"

  if [[ -n "$host_flag" ]]; then
    spawn_remote "$host_flag" "$project"
  else
    spawn_local "$project"
  fi
}

spawn_local() {
  local project="$1"
  local proj_dir="$PROJECTS_DIR/$project"
  [[ -d "$proj_dir" ]] || err "project directory not found: $proj_dir"

  # Check image exists
  podman image exists "$AGENT_IMAGE" 2>/dev/null || \
    err "image '$AGENT_IMAGE' not found. Build with: trimtab agent build"

  local selinux
  selinux=$(detect_selinux)
  local run_cmd
  run_cmd=$(podman_run_cmd "$HOME" "$PROJECTS_DIR" "$project" "$selinux")

  if ! tmux has-session -t "$AGENT_SESSION" 2>/dev/null; then
    tmux new-session -d -s "$AGENT_SESSION" -n "$project"
    tmux send-keys -t "$AGENT_SESSION:$project" "$run_cmd" Enter
    printf "${G}created${N} session '%s' with window '%s' ${D}(container)${N}\n" "$AGENT_SESSION" "$project"
  else
    if tmux list-windows -t "$AGENT_SESSION" -F "#{window_name}" 2>/dev/null | grep -qx "$project"; then
      printf "${Y}window '%s' already exists${N} — attaching\n" "$project"
    else
      tmux new-window -t "$AGENT_SESSION" -n "$project"
      tmux send-keys -t "$AGENT_SESSION:$project" "$run_cmd" Enter
      printf "${G}created${N} window '%s' in session '%s' ${D}(container)${N}\n" "$project" "$AGENT_SESSION"
    fi
  fi

  if [[ -z "${TMUX:-}" ]]; then
    exec tmux attach-session -t "$AGENT_SESSION:$project"
  else
    tmux select-window -t "$AGENT_SESSION:$project"
    printf "switched to window '%s'\n" "$project"
  fi
}

spawn_remote() {
  local host_alias="$1" project="$2"
  local ssh_host="" remote_projects=""

  # Find host config
  for entry in "${REMOTE_HOSTS[@]}"; do
    parse_host "$entry"
    if [[ "$HOST_ALIAS" == "$host_alias" ]]; then
      ssh_host="$HOST_SSH"
      remote_projects="$HOST_PROJECTS"
      break
    fi
  done

  [[ -z "$ssh_host" ]] && err "unknown host '$host_alias'. Check $HOSTS_FILE"

  # Verify project directory exists on remote
  remote_cmd "$ssh_host" "test -d '$remote_projects/$project'" || \
    err "project directory not found on $host_alias: $remote_projects/$project"

  # Verify image exists on remote
  remote_cmd "$ssh_host" "podman image exists $AGENT_IMAGE" 2>/dev/null || \
    err "image '$AGENT_IMAGE' not found on $host_alias. Build with: trimtab agent build --on $host_alias"

  local selinux
  selinux=$(detect_selinux_remote "$ssh_host")

  # Derive home dir from remote_projects (e.g., /home/mac/1-Projects → /home/mac)
  local remote_home
  remote_home=$(dirname "$remote_projects")
  local run_cmd
  run_cmd=$(podman_run_cmd "$remote_home" "$remote_projects" "$project" "$selinux")

  # Check if window already exists
  local exists
  exists=$(remote_cmd "$ssh_host" "tmux list-windows -t $AGENT_SESSION -F '#{window_name}' 2>/dev/null" | grep -cx "$project") || exists=0

  if (( exists > 0 )); then
    printf "${Y}window '%s' already exists on %s${N}\n" "$project" "$host_alias"
  else
    # Create session or window
    remote_cmd "$ssh_host" "
      if ! tmux has-session -t $AGENT_SESSION 2>/dev/null; then
        tmux new-session -d -s $AGENT_SESSION -n '$project'
      else
        tmux new-window -t $AGENT_SESSION -n '$project'
      fi
      tmux send-keys -t $AGENT_SESSION:'$project' '$run_cmd' Enter
    " || err "failed to create session on $host_alias"
    printf "${G}created${N} window '%s' on %s (%s) ${D}(container)${N}\n" "$project" "$host_alias" "$ssh_host"
  fi

  printf "\nTo attach: ${B}ssh -t %s 'tmux attach -t %s:%s'${N}\n" "$ssh_host" "$AGENT_SESSION" "$project"
}

cmd_peek() {
  local lines=50
  local follow=0
  local target_input=""

  while (( $# > 0 )); do
    case "$1" in
      -n|--lines) lines="$2"; shift 2 ;;
      -f|--follow) follow=1; shift ;;
      *) target_input="$1"; shift ;;
    esac
  done

  [[ -z "$target_input" ]] && err "usage: trimtab agent peek <project|host:project> [-n lines] [-f]"

  resolve_target "$target_input"

  if [[ "$RESOLVED_HOST" == "local" ]]; then
    if (( follow )); then
      exec watch -n 1 "tmux capture-pane -t '$RESOLVED_TARGET' -p -S -$lines"
    else
      tmux capture-pane -t "$RESOLVED_TARGET" -p -S "-$lines"
    fi
  else
    if (( follow )); then
      exec watch -n 1 "ssh -o ConnectTimeout=3 -o BatchMode=yes '$RESOLVED_SSH' 'tmux capture-pane -t \"$RESOLVED_TARGET\" -p -S -$lines'"
    else
      remote_cmd "$RESOLVED_SSH" "tmux capture-pane -t '$RESOLVED_TARGET' -p -S -$lines"
    fi
  fi
}

cmd_send() {
  local target_input="${1:-}"
  shift || true
  local text="$*"

  [[ -z "$target_input" ]] && err "usage: trimtab agent send <project|host:project> <text>"
  [[ -z "$text" ]] && err "usage: trimtab agent send <project|host:project> <text>"

  resolve_target "$target_input"

  if [[ "$RESOLVED_HOST" == "local" ]]; then
    printf "${D}sending to %s (%s):${N} %s\n" "$target_input" "$RESOLVED_TARGET" "$text"
    tmux send-keys -t "$RESOLVED_TARGET" "$text" Enter
  else
    printf "${D}sending to %s on %s (%s):${N} %s\n" "$target_input" "$RESOLVED_HOST" "$RESOLVED_TARGET" "$text"
    local escaped_text="${text//\'/\'\\\'\'}"
    remote_cmd "$RESOLVED_SSH" "tmux send-keys -t '$RESOLVED_TARGET' '$escaped_text' Enter"
  fi
}

cmd_broadcast() {
  local text="$*"
  [[ -z "$text" ]] && err "usage: trimtab agent broadcast <text>"

  discover_agents

  # Collect all tmux-accessible targets
  local targets=()
  local projects=()
  local hosts=()
  for i in "${!AGENT_PROJECTS[@]}"; do
    [[ "${AGENT_TARGETS[$i]}" == "—" ]] && continue
    targets+=("${AGENT_TARGETS[$i]}")
    projects+=("${AGENT_PROJECTS[$i]}")
    hosts+=("${AGENT_HOSTS[$i]}")
  done

  if (( ${#targets[@]} == 0 )); then
    err "no tmux agent sessions found"
  fi

  printf "Will send to ${B}%d${N} agents:\n" "${#targets[@]}"
  for i in "${!targets[@]}"; do
    if [[ "${hosts[$i]}" == "local" ]]; then
      printf "  %s  (%s)\n" "${projects[$i]}" "${targets[$i]}"
    else
      printf "  %s  (%s) ${D}[%s]${N}\n" "${projects[$i]}" "${targets[$i]}" "${hosts[$i]}"
    fi
  done
  printf "Text: ${B}%s${N}\n" "$text"

  read -rp "Send? [y/N] " confirm
  [[ "$confirm" =~ ^[Yy]$ ]] || { echo "cancelled"; exit 0; }

  for i in "${!targets[@]}"; do
    local t="${targets[$i]}"
    local h="${hosts[$i]}"

    if [[ "$h" == "local" ]]; then
      tmux send-keys -t "$t" "$text" Enter
    else
      # Remote target format: "alias:session:window.pane" → tmux target is "session:window.pane"
      local alias="${t%%:*}"
      local tmux_target="${t#*:}"
      local ssh_host=""
      for entry in "${REMOTE_HOSTS[@]}"; do
        parse_host "$entry"
        [[ "$HOST_ALIAS" == "$alias" ]] && ssh_host="$HOST_SSH" && break
      done
      local escaped_text="${text//\'/\'\\\'\'}"
      remote_cmd "$ssh_host" "tmux send-keys -t '$tmux_target' '$escaped_text' Enter"
    fi
    printf "  ${G}sent${N} → %s %s\n" "${projects[$i]}" "${D}[${h}]${N}"
  done
}

cmd_auth() {
  local host_alias="${1:-}"
  [[ -z "$host_alias" ]] && err "usage: trimtab agent auth <host>"

  local ssh_host="" remote_projects=""
  for entry in "${REMOTE_HOSTS[@]}"; do
    parse_host "$entry"
    if [[ "$HOST_ALIAS" == "$host_alias" ]]; then
      ssh_host="$HOST_SSH"
      remote_projects="$HOST_PROJECTS"
      break
    fi
  done
  [[ -z "$ssh_host" ]] && err "unknown host '$host_alias'. Check $HOSTS_FILE"

  local remote_home
  remote_home=$(dirname "$remote_projects")

  printf "${C}Launching Claude on %s for auth...${N}\n" "$host_alias"

  # Create a temp tmux session for auth (unique names to avoid conflicts)
  local auth_session="auth-$$"
  local auth_container="auth-${host_alias}-$$"
  local selinux
  selinux=$(detect_selinux_remote "$ssh_host")
  local run_cmd
  run_cmd=$(podman_run_cmd "$remote_home" "$remote_projects" "trimtab" "$selinux" "$auth_container")

  remote_cmd "$ssh_host" "
    tmux new-session -d -s $auth_session
    tmux send-keys -t $auth_session '$run_cmd' Enter
  " || err "failed to start auth session on $host_alias"

  # Cleanup helper — kill temp tmux session and container
  auth_cleanup() {
    remote_cmd "$ssh_host" "tmux kill-session -t $auth_session 2>/dev/null; podman rm -f $auth_container 2>/dev/null" 2>/dev/null || true
  }

  # Send Enter to remote tmux pane
  auth_send_enter() {
    remote_cmd "$ssh_host" "tmux send-keys -t $auth_session Enter" 2>/dev/null
  }

  # Send text to remote tmux pane (with delay before Enter for Claude TUI)
  auth_send_text() {
    remote_cmd "$ssh_host" "tmux send-keys -t $auth_session '$1'; sleep 0.3; tmux send-keys -t $auth_session Enter" 2>/dev/null
  }

  # Capture remote pane text
  auth_pane() {
    remote_cmd "$ssh_host" "tmux capture-pane -t $auth_session -p -S -${1:-30}" 2>/dev/null
  }

  # Extract OAuth URL from pane (handles multi-line wrapped URLs)
  extract_url() {
    echo "$1" | awk '/^https:\/\/claude\.ai\/oauth/{p=1} p{if(/^[[:space:]]*$/)exit; printf "%s",$0}' | tr -d ' '
  }

  # Navigate wizard + auth flow via state machine
  # States: wizard steps → OAuth URL → code paste → post-auth wizards → prompt
  printf "${D}Waiting for Claude to start...${N}\n"
  local state="waiting"
  for i in $(seq 1 120); do
    local pane_text
    pane_text=$(auth_pane 30)

    # Terminal state: main prompt reached
    if echo "$pane_text" | grep -q "Tips for getting started\|What can I help\|Type a message\|for shortcuts"; then
      printf "${G}Authenticated on %s!${N}\n" "$host_alias"
      auth_cleanup
      return
    fi

    case "$state" in
      waiting)
        # Dismiss stale credential errors
        if echo "$pane_text" | grep -q "Press Enter to retry"; then
          printf "${D}  dismissing auth error...${N}\n"
          auth_send_enter
          sleep 3; continue
        fi

        # Wizard steps (theme selection, login method)
        if echo "$pane_text" | grep -q "Choose the text style\|Select login method"; then
          printf "${D}  accepting wizard default...${N}\n"
          auth_send_enter
          sleep 3; continue
        fi

        # OAuth URL appeared — extract and prompt user
        if echo "$pane_text" | grep -q "Browser didn't open"; then
          local url
          url=$(extract_url "$pane_text")
          if [[ -n "$url" ]]; then
            printf "\n${B}Opening auth URL in browser...${N}\n"
            xdg-open "$url" 2>/dev/null || open "$url" 2>/dev/null || true

            printf "\nAfter authenticating, paste the ${B}full code${N} (including the #state part):\n"
            read -rp "> " auth_code
            [[ -z "$auth_code" ]] && { auth_cleanup; err "no code provided"; }

            auth_send_text "$auth_code"
            state="post_auth"
            sleep 5; continue
          fi
        fi
        ;;

      post_auth)
        # After successful auth, auto-dismiss remaining wizard steps
        # "Login successful" / "Press Enter to continue" / security note / trust folder / effort
        if echo "$pane_text" | grep -q "Press Enter to continue\|Yes, I trust\|Use high effort\|Select login method\|Choose the text style"; then
          printf "${D}  accepting post-auth default...${N}\n"
          auth_send_enter
          sleep 3; continue
        fi

        # Check for auth failure
        if echo "$pane_text" | grep -q "Invalid code\|OAuth error"; then
          printf "${R}Auth failed.${N} Try again? (y/n): "
          read -rp "" retry
          if [[ "$retry" =~ ^[Yy]$ ]]; then
            auth_send_enter  # dismiss error
            state="waiting"
            sleep 3; continue
          else
            auth_cleanup
            return
          fi
        fi
        ;;
    esac

    sleep 2
  done

  printf "\n${Y}Auth may still be in progress.${N}\n"
  printf "Attach: ${B}ssh -t %s 'tmux attach -t %s'${N}\n" "$ssh_host" "$auth_session"
}

cmd_attach() {
  local host_alias="${1:-}"

  if [[ -z "$host_alias" ]]; then
    # Local attach
    if ! tmux has-session -t "$AGENT_SESSION" 2>/dev/null; then
      err "no local '$AGENT_SESSION' session. Start one with: trimtab agent spawn <project>"
    fi
    exec tmux attach-session -t "$AGENT_SESSION"
  fi

  # Remote attach
  local ssh_host=""
  for entry in "${REMOTE_HOSTS[@]}"; do
    parse_host "$entry"
    if [[ "$HOST_ALIAS" == "$host_alias" ]]; then
      ssh_host="$HOST_SSH"
      break
    fi
  done
  [[ -z "$ssh_host" ]] && err "unknown host '$host_alias'. Check $HOSTS_FILE"

  remote_cmd "$ssh_host" "tmux has-session -t $AGENT_SESSION 2>/dev/null" || \
    err "no '$AGENT_SESSION' session on $host_alias. Start one with: trimtab agent spawn --on $host_alias <project>"

  exec ssh -t "$ssh_host" "tmux attach-session -t $AGENT_SESSION"
}

cmd_build() {
  local host_flag=""

  while (( $# > 0 )); do
    case "$1" in
      --on) host_flag="$2"; shift 2 ;;
      *)    shift ;;
    esac
  done

  local containerfile="$PROJECTS_DIR/trimtab/containers/agent/Containerfile"

  if [[ -z "$host_flag" ]]; then
    # Local build
    [[ -f "$containerfile" ]] || err "Containerfile not found: $containerfile"
    printf "${C}Building %s locally...${N}\n" "$AGENT_IMAGE"
    podman build -t "$AGENT_IMAGE" "$(dirname "$containerfile")" || err "build failed"
    ok "image $AGENT_IMAGE built"
    podman images "$AGENT_IMAGE" --format "Size: {{.Size}}"
  else
    # Remote build
    local ssh_host="" remote_projects=""
    for entry in "${REMOTE_HOSTS[@]}"; do
      parse_host "$entry"
      if [[ "$HOST_ALIAS" == "$host_flag" ]]; then
        ssh_host="$HOST_SSH"
        remote_projects="$HOST_PROJECTS"
        break
      fi
    done
    [[ -z "$ssh_host" ]] && err "unknown host '$host_flag'. Check $HOSTS_FILE"

    local remote_containerfile="$remote_projects/trimtab/containers/agent/Containerfile"
    remote_cmd "$ssh_host" "test -f '$remote_containerfile'" || \
      err "Containerfile not found on $host_flag: $remote_containerfile"

    printf "${C}Building %s on %s...${N}\n" "$AGENT_IMAGE" "$host_flag"
    ssh -o ConnectTimeout=5 "$ssh_host" \
      "podman build -t $AGENT_IMAGE $(dirname "$remote_containerfile")" || err "build failed on $host_flag"
    ok "image $AGENT_IMAGE built on $host_flag"
  fi
}

# ============================================================
# DISPATCH
# ============================================================

subcmd="${1:-list}"
shift 2>/dev/null || true

case "$subcmd" in
  list|ls)       cmd_list "$@" ;;
  spawn)         cmd_spawn "$@" ;;
  build)         cmd_build "$@" ;;
  auth)          cmd_auth "$@" ;;
  attach|a)      cmd_attach "$@" ;;
  peek)          cmd_peek "$@" ;;
  send)          cmd_send "$@" ;;
  broadcast|bc)  cmd_broadcast "$@" ;;
  help|-h|--help)
    cat <<EOF
trimtab agent — manage Claude Code sessions via tmux (local + remote)

Usage: trimtab agent <command> [args...]

Commands:
  list                                    Discover all Claude sessions (local + remote)
  spawn [--on <host>] <project>           Launch Claude in a container via tmux
  build [--on <host>]                     Build the trimtab-agent container image
  auth <host>                             Authenticate Claude Code on a remote host
  attach [host]                           Attach to the agents tmux session (local or remote)
  peek <project|host:project> [-n N] [-f] Capture recent pane output (default: 50 lines)
  send <project|host:project> <text>      Send keystrokes to an agent session
  broadcast <text>                        Send to all managed agent windows (with confirm)

Aliases: ls=list, a=attach, bc=broadcast

Remote hosts configured in: ${HOSTS_FILE}
Format: alias|ssh_host|remote_projects_dir (one per line)

Examples:
  trimtab agent                                  # list all sessions (local + remote)
  trimtab agent build                            # build container image locally
  trimtab agent build --on thor                  # build on remote host
  trimtab agent spawn gridplay-v1                # start locally (in container)
  trimtab agent spawn --on thor gridplay-v1      # start on remote host (in container)
  trimtab agent auth thor                        # authenticate Claude on thor (opens browser)
  trimtab agent attach thor                      # attach to thor's agents session
  trimtab agent peek thor:gridplay-v1            # peek at remote session
  trimtab agent send thor:gridplay-v1 "/status"  # send to remote session
  trimtab agent broadcast "/compact"             # send to all agents everywhere
EOF
    ;;
  *)
    err "unknown subcommand '$subcmd'. Run 'trimtab agent help' for usage."
    ;;
esac
