#!/usr/bin/env bash
# trimtab steer — audit and manage trim tab infrastructure across projects
# Shows CLAUDE.md, memory files, skills, quality tools, and config drift
set -euo pipefail

R=$'\033[0;31m'   G=$'\033[0;32m'   D=$'\033[2m'
B=$'\033[1m'      C=$'\033[0;36m'   Y=$'\033[0;33m'
A=$'\033[0;33m'   N=$'\033[0m'

PROJECTS_DIR="$HOME/1-Projects"
CMD="${1:-audit}"

section() { printf "\n${B}${C}── %s${N}\n" "$1"; }

# ============================================================
# AUDIT — show trim tab infrastructure across all projects
# ============================================================
cmd_audit() {
  section "Trim Tab Infrastructure"
  printf "  ${D}%-22s %s %s %s %s %s${N}\n" "PROJECT" "CLAUDE" "MEMORY" "SKILL" "TASKS" "GIT"
  printf "  ${D}%-22s %s %s %s %s %s${N}\n" "───────" "──────" "──────" "─────" "─────" "───"

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Check for each trim tab
    has_claude="  ${D}·${N} "
    has_memory="  ${D}·${N} "
    has_skills="  ${D}·${N} "
    has_tasks="  ${D}·${N} "
    has_git="  ${D}·${N} "

    # CLAUDE.md — check root and .claude/
    if [[ -f "$proj_dir/CLAUDE.md" ]]; then
      lines=$(wc -l < "$proj_dir/CLAUDE.md")
      has_claude="${G}${lines}L${N}"
      has_claude=$(printf "%-6s" "$has_claude")
    fi

    # Memory files
    memory_dir="$HOME/.claude/projects/-home-mchughson-1-Projects-${proj}/memory"
    if [[ -d "$memory_dir" ]]; then
      mcount=$(find "$memory_dir" -name "*.md" 2>/dev/null | wc -l)
      if (( mcount > 0 )); then
        has_memory="${G}${mcount}${N}   "
      fi
    fi

    # Skills — check project-level .claude/skills/
    if [[ -d "$proj_dir/.claude/skills" ]]; then
      scount=$(find "$proj_dir/.claude/skills" -name "*.md" 2>/dev/null | wc -l)
      if (( scount > 0 )); then
        has_skills="${G}${scount}${N}  "
      fi
    fi

    # Task Master
    if [[ -f "$proj_dir/.taskmaster/tasks/tasks.json" ]]; then
      has_tasks="${G}yes${N}"
      has_tasks=$(printf "%-5s" "$has_tasks")
    fi

    # Git
    if [[ -d "$proj_dir/.git" ]]; then
      has_git="${G}yes${N}"
    fi

    printf "  %-22s %s %s %s %s %s\n" "$proj" "$has_claude" "$has_memory" "$has_skills" "$has_tasks" "$has_git"
  done

  # Global trim tabs
  section "Global Trim Tabs"
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    lines=$(wc -l < "$HOME/.claude/CLAUDE.md")
    printf "  ${G}●${N} ~/.claude/CLAUDE.md          ${D}(%d lines)${N}\n" "$lines"
  fi

  global_memory="$HOME/.claude/projects/-home-mchughson-1-Projects/memory"
  if [[ -d "$global_memory" ]]; then
    mcount=$(find "$global_memory" -name "*.md" 2>/dev/null | wc -l)
    printf "  ${G}●${N} Global memory files           ${D}(%d files)${N}\n" "$mcount"
  fi

  skill_count=$(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | wc -l)
  if (( skill_count > 0 )); then
    printf "  ${G}●${N} Global skills                 ${D}(%d skills)${N}\n" "$skill_count"
    while IFS= read -r skill_file; do
      skill_name=$(basename "$(dirname "$skill_file")")
      printf "    ${A}%s${N}\n" "$skill_name"
    done < <(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | sort)
  fi

  # Global hooks
  if [[ -f "$HOME/.claude/settings.json" ]] && grep -q '"hooks"' "$HOME/.claude/settings.json" 2>/dev/null; then
    printf "  ${G}●${N} Global Claude hooks           ${D}(active)${N}\n"
  else
    printf "  ${R}●${N} Global Claude hooks           ${D}(none)${N}\n"
  fi
}

# ============================================================
# GAPS — show projects missing key infrastructure
# ============================================================
cmd_gaps() {
  section "Projects Missing Infrastructure"

  local missing_claude=()
  local missing_git=()
  local missing_hook=()
  local missing_credo=()
  local missing_precommit=()
  local missing_ci=()

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Skip non-code directories
    [[ -d "$proj_dir/.git" ]] || [[ -f "$proj_dir/mix.exs" ]] || [[ -f "$proj_dir/package.json" ]] || continue

    # Universal checks
    if [[ ! -f "$proj_dir/CLAUDE.md" ]]; then
      missing_claude+=("$proj")
    fi
    if [[ ! -d "$proj_dir/.git" ]]; then
      missing_git+=("$proj")
    fi

    # Git hook check
    if [[ -d "$proj_dir/.git" ]] && [[ ! -x "$proj_dir/.git/hooks/pre-commit" ]]; then
      missing_hook+=("$proj")
    fi

    # Elixir-specific checks
    if [[ -f "$proj_dir/mix.exs" ]]; then
      if ! grep -q "credo" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_credo+=("$proj")
      fi
      if ! grep -q "precommit" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_precommit+=("$proj")
      fi
    fi

    # CI/CD check
    if [[ -d "$proj_dir/.git" ]]; then
      has_ci=false
      [[ -d "$proj_dir/.github/workflows" ]] && has_ci=true
      [[ -f "$proj_dir/.gitlab-ci.yml" ]] && has_ci=true
      if ! $has_ci; then
        missing_ci+=("$proj")
      fi
    fi
  done

  # Production readiness checks — only for projects with CI (they're production-bound)
  local missing_release=()
  local missing_health=()
  local missing_deploy=()
  local missing_backup=()
  local missing_errortracking=()
  local missing_envtemplate=()

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Only check projects that have CI
    local has_ci=false
    [[ -d "$proj_dir/.github/workflows" ]] && has_ci=true
    [[ -f "$proj_dir/.gitlab-ci.yml" ]] && has_ci=true
    $has_ci || continue

    # Release module (Elixir-specific) — check root and server/ for monorepos
    if [[ -f "$proj_dir/mix.exs" ]] || [[ -f "$proj_dir/server/mix.exs" ]]; then
      if ! grep -rq "Release" "$proj_dir"/lib/*/release.ex "$proj_dir"/server/lib/*/release.ex 2>/dev/null; then
        missing_release+=("$proj")
      fi
    fi

    # Health endpoint — check lib/, server/lib/, src/ for monorepos
    if ! grep -rq '/health\|/api/health' "$proj_dir/lib/" "$proj_dir/server/lib/" "$proj_dir/src/" 2>/dev/null; then
      missing_health+=("$proj")
    fi

    # Deploy scripts
    if [[ ! -d "$proj_dir/deploy" ]] && [[ ! -f "$proj_dir/graybeam.toml" ]]; then
      missing_deploy+=("$proj")
    fi

    # Backup script
    if [[ ! -f "$proj_dir/deploy/backup.sh" ]] && ! grep -q "backup" "$proj_dir/graybeam.toml" 2>/dev/null; then
      missing_backup+=("$proj")
    fi

    # Error tracking — check root and subdirs for monorepos
    if ! grep -rq 'sentry\|Sentry\|rollbar\|bugsnag' "$proj_dir/mix.exs" "$proj_dir/server/mix.exs" "$proj_dir/package.json" "$proj_dir/frontend/package.json" "$proj_dir/Cargo.toml" 2>/dev/null; then
      missing_errortracking+=("$proj")
    fi

    # Env template
    if [[ ! -f "$proj_dir/.env.example" ]] && [[ ! -f "$proj_dir/deploy/provision.sh" ]]; then
      missing_envtemplate+=("$proj")
    fi
  done

  # Report each category
  if (( ${#missing_claude[@]} > 0 )); then
    printf "  ${Y}No CLAUDE.md:${N}\n"
    for p in "${missing_claude[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_git[@]} > 0 )); then
    printf "  ${Y}No git repo:${N}\n"
    for p in "${missing_git[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_hook[@]} > 0 )); then
    printf "  ${Y}No pre-commit hook:${N}\n"
    for p in "${missing_hook[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_credo[@]} > 0 )); then
    printf "  ${Y}Elixir without Credo:${N}\n"
    for p in "${missing_credo[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_precommit[@]} > 0 )); then
    printf "  ${Y}Elixir without mix precommit:${N}\n"
    for p in "${missing_precommit[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_ci[@]} > 0 )); then
    printf "  ${Y}No CI/CD pipeline:${N}\n"
    for p in "${missing_ci[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  # Production readiness report (only if any CI projects exist)
  local prod_gaps=$(( ${#missing_release[@]} + ${#missing_health[@]} + ${#missing_deploy[@]} + ${#missing_backup[@]} + ${#missing_errortracking[@]} + ${#missing_envtemplate[@]} ))
  if (( prod_gaps > 0 )); then
    section "Production Readiness (projects with CI)"

    if (( ${#missing_release[@]} > 0 )); then
      printf "  ${Y}Elixir without Release module:${N}\n"
      for p in "${missing_release[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_health[@]} > 0 )); then
      printf "  ${Y}No health endpoint:${N}\n"
      for p in "${missing_health[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_deploy[@]} > 0 )); then
      printf "  ${Y}No deploy scripts:${N}\n"
      for p in "${missing_deploy[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_backup[@]} > 0 )); then
      printf "  ${Y}No backup script:${N}\n"
      for p in "${missing_backup[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_errortracking[@]} > 0 )); then
      printf "  ${Y}No error tracking:${N}\n"
      for p in "${missing_errortracking[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_envtemplate[@]} > 0 )); then
      printf "  ${Y}No .env template:${N}\n"
      for p in "${missing_envtemplate[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi
  fi

  # Summary
  local total_gaps=$(( ${#missing_claude[@]} + ${#missing_hook[@]} + ${#missing_credo[@]} + ${#missing_precommit[@]} + ${#missing_ci[@]} + prod_gaps ))
  if (( total_gaps == 0 )); then
    printf "  ${G}All projects have full quality and production infrastructure.${N}\n"
  else
    local dev_gaps=$(( ${#missing_claude[@]} + ${#missing_hook[@]} + ${#missing_credo[@]} + ${#missing_precommit[@]} + ${#missing_ci[@]} ))
    printf "  ${D}Dev quality gaps: %d | Production readiness gaps: %d${N}\n" "$dev_gaps" "$prod_gaps"
    printf "  ${D}Fix with: trimtab init <project>${N}\n"
  fi
}

# ============================================================
# SYNC — extract and propagate lessons across projects
# ============================================================
cmd_sync() {
  local use_ai=false
  shift 2>/dev/null || true
  for arg in "$@"; do
    [[ "$arg" == "--ai" ]] && use_ai=true
  done

  section "Cross-Project Lesson Extraction"

  # Collect all pitfalls, gotchas, known issues, and lessons from CLAUDE.md files
  local all_lessons=""
  local project_count=0
  local lesson_count=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    local proj=$(basename "$proj_dir")
    local claude_file="$proj_dir/CLAUDE.md"
    [[ -f "$claude_file" ]] || continue

    # Extract sections: Common Pitfalls, Known Issues, Critical Gotchas, Errors & Lessons
    local extracted=""
    extracted=$(awk '
      /^##+ .*(Pitfall|Gotcha|Known Issue|Known Problem|Errors|Lesson|Regression|Warning)/ { capture=1; next }
      /^##+ / { capture=0 }
      capture && /^[[:space:]]*[-*]/ { print }
    ' "$claude_file" 2>/dev/null)

    if [[ -n "$extracted" ]]; then
      local count
      count=$(echo "$extracted" | wc -l)
      lesson_count=$((lesson_count + count))
      project_count=$((project_count + 1))
      printf "  ${G}●${N} %-24s ${D}%d lessons${N}\n" "$proj" "$count"
      all_lessons+="
## ${proj}
${extracted}
"
    fi
  done

  # Also extract from memory files
  section "Memory File Lessons"
  local memory_lessons=""

  for memory_dir in "$HOME/.claude/projects/-home-mchughson-1-Projects-"*/memory/; do
    [[ -d "$memory_dir" ]] || continue
    local proj
    proj=$(basename "$(dirname "$memory_dir")")
    proj="${proj#-home-mchughson-1-Projects-}"

    for md_file in "$memory_dir"*.md; do
      [[ -f "$md_file" ]] || continue

      local extracted=""
      extracted=$(awk '
        /^##+ .*(Lesson|Error|Pitfall|Mistake|Regression|Fix|Warning|Concern|Bug)/ { capture=1; next }
        /^##+ / { capture=0 }
        capture && /^[[:space:]]*[-*]/ { print }
      ' "$md_file" 2>/dev/null)

      if [[ -n "$extracted" ]]; then
        local count
        count=$(echo "$extracted" | wc -l)
        lesson_count=$((lesson_count + count))
        printf "  ${G}●${N} %-24s ${D}%d lessons${N}\n" "$proj/$(basename "$md_file")" "$count"
        memory_lessons+="
## ${proj} (memory)
${extracted}
"
      fi
    done
  done

  # Check what's already in global CLAUDE.md
  local global_lessons=""
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    global_lessons=$(awk '
      /^##+ .*(Safe Deletion|Safe Process|Debug|Pushback|Enforcement|Pitfall|Lesson)/ { capture=1; next }
      /^##+ / { capture=0 }
      capture && /^[[:space:]]*[-*]/ { print }
    ' "$HOME/.claude/CLAUDE.md" 2>/dev/null)
  fi

  local global_count=0
  [[ -n "$global_lessons" ]] && global_count=$(echo "$global_lessons" | wc -l)

  section "Summary"
  printf "  ${D}Projects with documented lessons:${N} %d\n" "$project_count"
  printf "  ${D}Total lessons extracted:${N}          %d\n" "$lesson_count"
  printf "  ${D}Global CLAUDE.md rules:${N}           %d\n" "$global_count"

  # Without --ai, just show the raw extraction
  if ! $use_ai; then
    if (( lesson_count > 0 )); then
      section "All Extracted Lessons"
      echo "$all_lessons" | while IFS= read -r line; do
        if [[ "$line" =~ ^##\  ]]; then
          printf "\n  ${C}%s${N}\n" "${line## }"
        elif [[ -n "$line" ]]; then
          printf "  %s\n" "$line"
        fi
      done
      if [[ -n "$memory_lessons" ]]; then
        echo "$memory_lessons" | while IFS= read -r line; do
          if [[ "$line" =~ ^##\  ]]; then
            printf "\n  ${C}%s${N}\n" "${line## }"
          elif [[ -n "$line" ]]; then
            printf "  %s\n" "$line"
          fi
        done
      fi
      printf "\n  ${D}Run 'trimtab steer sync --ai' for AI-powered pattern analysis${N}\n"
    fi
    return
  fi

  # ── AI-powered analysis ──
  section "AI Pattern Analysis"
  printf "  ${D}Analyzing %d lessons across %d projects...${N}\n" "$lesson_count" "$project_count"

  # Find API key
  local api_key=""
  for env_file in "$PROJECTS_DIR/decision_forge_v2/.env" "$PROJECTS_DIR/ai-brand-studio/.env" "$HOME/.env"; do
    if [[ -f "$env_file" ]]; then
      api_key=$(grep "^OPENROUTER_API_KEY=" "$env_file" 2>/dev/null | cut -d'=' -f2 | tr -d '"' | tr -d "'")
      [[ -n "$api_key" ]] && break
    fi
  done

  if [[ -z "$api_key" ]]; then
    printf "  ${R}No OPENROUTER_API_KEY found${N}\n"
    return 1
  fi

  local prompt="/no_think
You are analyzing lessons learned and common pitfalls extracted from CLAUDE.md files and memory files across ${project_count} software projects.

## Project Lessons
${all_lessons}
${memory_lessons}

## Currently in Global CLAUDE.md
${global_lessons}

Your task:
1. IDENTIFY cross-cutting patterns — lessons that appear in 2+ projects or apply universally
2. FLAG lessons that are NOT yet in the global CLAUDE.md but should be
3. DEDUPLICATE — merge similar lessons into concise rules
4. CATEGORIZE as: [PROMOTE TO GLOBAL] [PROJECT-SPECIFIC] [ALREADY GLOBAL]

Format your response as:

### Promote to Global CLAUDE.md
- [lesson] — appears in: [project1, project2]

### Cross-Cutting Patterns
- [pattern description] — affected projects: [list]

### Project-Specific (leave in place)
- [project]: [lesson summary]

Be concise. Focus on actionable rules, not descriptions."

  local payload
  payload=$(python3 -c "
import json, sys
print(json.dumps({
    'model': 'qwen/qwen3-32b',
    'messages': [{'role': 'user', 'content': sys.argv[1]}],
    'max_tokens': 2000,
    'temperature': 0.3
}))
" "$prompt")

  local response
  response=$(curl -s -X POST "https://openrouter.ai/api/v1/chat/completions" \
    -H "Authorization: Bearer $api_key" \
    -H "Content-Type: application/json" \
    -d "$payload" 2>/dev/null)

  local content
  content=$(echo "$response" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(data['choices'][0]['message']['content'])
except Exception as e:
    print(f'Error parsing response: {e}')
" 2>/dev/null)

  if [[ -n "$content" ]]; then
    printf "\n"
    echo "$content" | while IFS= read -r line; do
      if [[ "$line" =~ ^###\  ]]; then
        printf "  ${B}${C}%s${N}\n" "$line"
      elif [[ "$line" =~ ^-\  ]]; then
        printf "  %s\n" "$line"
      elif [[ -n "$line" ]]; then
        printf "  ${D}%s${N}\n" "$line"
      fi
    done
    printf "\n  ${D}Review above and add relevant items to ~/.claude/CLAUDE.md${N}\n"
  else
    printf "  ${R}Empty response from AI${N}\n"
  fi
}

# ============================================================
# DISPATCH
# ============================================================
case "$CMD" in
  audit)  cmd_audit ;;
  gaps)   cmd_gaps ;;
  sync)   cmd_sync "$@" ;;
  *)
    echo "trimtab steer — manage trim tab infrastructure"
    echo ""
    echo "Usage: trimtab steer [command]"
    echo ""
    echo "Commands:"
    echo "  audit    Show trim tab infrastructure across all projects (default)"
    echo "  gaps     Show projects missing key infrastructure"
    echo "  sync     Extract and propagate lessons across projects (--ai for analysis)"
    ;;
esac
