#!/usr/bin/env bash
# trimtab steer — audit and manage trim tab infrastructure across projects
# Shows CLAUDE.md, memory files, skills, quality tools, and config drift
set -euo pipefail

R=$'\033[0;31m'   G=$'\033[0;32m'   D=$'\033[2m'
B=$'\033[1m'      C=$'\033[0;36m'   Y=$'\033[0;33m'
A=$'\033[0;33m'   N=$'\033[0m'

PROJECTS_DIR="$HOME/1-Projects"
CMD="${1:-audit}"

section() { printf "\n${B}${C}── %s${N}\n" "$1"; }

# ============================================================
# AUDIT — show trim tab infrastructure across all projects
# ============================================================
cmd_audit() {
  section "Trim Tab Infrastructure"
  printf "  ${D}%-22s %s %s %s %s %s${N}\n" "PROJECT" "CLAUDE" "MEMORY" "SKILL" "TASKS" "GIT"
  printf "  ${D}%-22s %s %s %s %s %s${N}\n" "───────" "──────" "──────" "─────" "─────" "───"

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Check for each trim tab
    has_claude="  ${D}·${N} "
    has_memory="  ${D}·${N} "
    has_skills="  ${D}·${N} "
    has_tasks="  ${D}·${N} "
    has_git="  ${D}·${N} "

    # CLAUDE.md — check root and .claude/
    if [[ -f "$proj_dir/CLAUDE.md" ]]; then
      lines=$(wc -l < "$proj_dir/CLAUDE.md")
      has_claude="${G}${lines}L${N}"
      has_claude=$(printf "%-6s" "$has_claude")
    fi

    # Memory files
    memory_dir="$HOME/.claude/projects/-home-mchughson-1-Projects-${proj}/memory"
    if [[ -d "$memory_dir" ]]; then
      mcount=$(find "$memory_dir" -name "*.md" 2>/dev/null | wc -l)
      if (( mcount > 0 )); then
        has_memory="${G}${mcount}${N}   "
      fi
    fi

    # Skills — check project-level .claude/skills/
    if [[ -d "$proj_dir/.claude/skills" ]]; then
      scount=$(find "$proj_dir/.claude/skills" -name "*.md" 2>/dev/null | wc -l)
      if (( scount > 0 )); then
        has_skills="${G}${scount}${N}  "
      fi
    fi

    # Task Master
    if [[ -f "$proj_dir/.taskmaster/tasks/tasks.json" ]]; then
      has_tasks="${G}yes${N}"
      has_tasks=$(printf "%-5s" "$has_tasks")
    fi

    # Git
    if [[ -d "$proj_dir/.git" ]]; then
      has_git="${G}yes${N}"
    fi

    printf "  %-22s %s %s %s %s %s\n" "$proj" "$has_claude" "$has_memory" "$has_skills" "$has_tasks" "$has_git"
  done

  # Global trim tabs
  section "Global Trim Tabs"
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    lines=$(wc -l < "$HOME/.claude/CLAUDE.md")
    printf "  ${G}●${N} ~/.claude/CLAUDE.md          ${D}(%d lines)${N}\n" "$lines"
  fi

  global_memory="$HOME/.claude/projects/-home-mchughson-1-Projects/memory"
  if [[ -d "$global_memory" ]]; then
    mcount=$(find "$global_memory" -name "*.md" 2>/dev/null | wc -l)
    printf "  ${G}●${N} Global memory files           ${D}(%d files)${N}\n" "$mcount"
  fi

  skill_count=$(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | wc -l)
  if (( skill_count > 0 )); then
    printf "  ${G}●${N} Global skills                 ${D}(%d skills)${N}\n" "$skill_count"
    while IFS= read -r skill_file; do
      skill_name=$(basename "$(dirname "$skill_file")")
      printf "    ${A}%s${N}\n" "$skill_name"
    done < <(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | sort)
  fi

  # Global hooks
  if [[ -f "$HOME/.claude/settings.json" ]] && grep -q '"hooks"' "$HOME/.claude/settings.json" 2>/dev/null; then
    printf "  ${G}●${N} Global Claude hooks           ${D}(active)${N}\n"
  else
    printf "  ${R}●${N} Global Claude hooks           ${D}(none)${N}\n"
  fi
}

# ============================================================
# GAPS — show projects missing key infrastructure
# ============================================================
cmd_gaps() {
  section "Projects Missing Infrastructure"

  local missing_claude=()
  local missing_git=()
  local missing_hook=()
  local missing_credo=()
  local missing_precommit=()
  local missing_ci=()

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Skip non-code directories
    [[ -d "$proj_dir/.git" ]] || [[ -f "$proj_dir/mix.exs" ]] || [[ -f "$proj_dir/package.json" ]] || continue

    # Universal checks
    if [[ ! -f "$proj_dir/CLAUDE.md" ]]; then
      missing_claude+=("$proj")
    fi
    if [[ ! -d "$proj_dir/.git" ]]; then
      missing_git+=("$proj")
    fi

    # Git hook check
    if [[ -d "$proj_dir/.git" ]] && [[ ! -x "$proj_dir/.git/hooks/pre-commit" ]]; then
      missing_hook+=("$proj")
    fi

    # Elixir-specific checks
    if [[ -f "$proj_dir/mix.exs" ]]; then
      if ! grep -q "credo" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_credo+=("$proj")
      fi
      if ! grep -q "precommit" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_precommit+=("$proj")
      fi
    fi

    # CI/CD check
    if [[ -d "$proj_dir/.git" ]]; then
      has_ci=false
      [[ -d "$proj_dir/.github/workflows" ]] && has_ci=true
      [[ -f "$proj_dir/.gitlab-ci.yml" ]] && has_ci=true
      if ! $has_ci; then
        missing_ci+=("$proj")
      fi
    fi
  done

  # Report each category
  if (( ${#missing_claude[@]} > 0 )); then
    printf "  ${Y}No CLAUDE.md:${N}\n"
    for p in "${missing_claude[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_git[@]} > 0 )); then
    printf "  ${Y}No git repo:${N}\n"
    for p in "${missing_git[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_hook[@]} > 0 )); then
    printf "  ${Y}No pre-commit hook:${N}\n"
    for p in "${missing_hook[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_credo[@]} > 0 )); then
    printf "  ${Y}Elixir without Credo:${N}\n"
    for p in "${missing_credo[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_precommit[@]} > 0 )); then
    printf "  ${Y}Elixir without mix precommit:${N}\n"
    for p in "${missing_precommit[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_ci[@]} > 0 )); then
    printf "  ${Y}No CI/CD pipeline:${N}\n"
    for p in "${missing_ci[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  # Summary
  local total_gaps=$(( ${#missing_claude[@]} + ${#missing_hook[@]} + ${#missing_credo[@]} + ${#missing_precommit[@]} + ${#missing_ci[@]} ))
  if (( total_gaps == 0 )); then
    printf "  ${G}All projects have full quality infrastructure.${N}\n"
  else
    printf "  ${D}Total gaps: %d across all categories${N}\n" "$total_gaps"
    printf "  ${D}Fix with: trimtab init <project>${N}\n"
  fi
}

# ============================================================
# DISPATCH
# ============================================================
case "$CMD" in
  audit)  cmd_audit ;;
  gaps)   cmd_gaps ;;
  *)
    echo "trimtab steer — manage trim tab infrastructure"
    echo ""
    echo "Usage: trimtab steer [command]"
    echo ""
    echo "Commands:"
    echo "  audit    Show trim tab infrastructure across all projects (default)"
    echo "  gaps     Show projects missing key infrastructure"
    ;;
esac
