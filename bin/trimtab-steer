#!/usr/bin/env bash
# trimtab steer — audit and manage trim tab infrastructure across projects
# Shows CLAUDE.md, memory files, skills, quality tools, and config drift
set -euo pipefail

source "$(dirname "$0")/trimtab-portable.sh"
source "$(dirname "$0")/trimtab-common.sh"

CHEZMOI_PREFIX=$(_chezmoi_projects_prefix)
CMD="${1:-audit}"
shift 2>/dev/null || true

# ============================================================
# AUDIT — show trim tab infrastructure across all projects
# ============================================================
cmd_audit() {
  section "Trim Tab Infrastructure"
  printf "  ${D}%-22s %s %s %s %s %s${N}\n" "PROJECT" "CLAUDE" "MEMORY" "SKILL" "TASKS" "GIT"
  printf "  ${D}%-22s %s %s %s %s %s${N}\n" "───────" "──────" "──────" "─────" "─────" "───"

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Check for each trim tab
    has_claude="  ${D}·${N} "
    has_memory="  ${D}·${N} "
    has_skills="  ${D}·${N} "
    has_tasks="  ${D}·${N} "
    has_git="  ${D}·${N} "

    # CLAUDE.md — check root and .claude/
    if [[ -f "$proj_dir/CLAUDE.md" ]]; then
      lines=$(wc -l < "$proj_dir/CLAUDE.md")
      has_claude="${G}${lines}L${N}"
      has_claude=$(printf "%-6s" "$has_claude")
    fi

    # Memory files
    memory_dir="$HOME/.claude/projects/-${CHEZMOI_PREFIX}-${proj}/memory"
    if [[ -d "$memory_dir" ]]; then
      mcount=$(find "$memory_dir" -name "*.md" 2>/dev/null | wc -l)
      if (( mcount > 0 )); then
        has_memory="${G}${mcount}${N}   "
      fi
    fi

    # Skills — check project-level .claude/skills/
    if [[ -d "$proj_dir/.claude/skills" ]]; then
      scount=$(find "$proj_dir/.claude/skills" -name "*.md" 2>/dev/null | wc -l)
      if (( scount > 0 )); then
        has_skills="${G}${scount}${N}  "
      fi
    fi

    # Task Master
    if [[ -f "$proj_dir/.taskmaster/tasks/tasks.json" ]]; then
      has_tasks="${G}yes${N}"
      has_tasks=$(printf "%-5s" "$has_tasks")
    fi

    # Git
    if [[ -d "$proj_dir/.git" ]]; then
      has_git="${G}yes${N}"
    fi

    printf "  %-22s %s %s %s %s %s\n" "$proj" "$has_claude" "$has_memory" "$has_skills" "$has_tasks" "$has_git"
  done

  # Global trim tabs
  section "Global Trim Tabs"
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    lines=$(wc -l < "$HOME/.claude/CLAUDE.md")
    printf "  ${G}●${N} ~/.claude/CLAUDE.md          ${D}(%d lines)${N}\n" "$lines"
  fi

  global_memory="$HOME/.claude/projects/-${CHEZMOI_PREFIX}/memory"
  if [[ -d "$global_memory" ]]; then
    mcount=$(find "$global_memory" -name "*.md" 2>/dev/null | wc -l)
    printf "  ${G}●${N} Global memory files           ${D}(%d files)${N}\n" "$mcount"
  fi

  skill_count=$(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | wc -l)
  if (( skill_count > 0 )); then
    printf "  ${G}●${N} Global skills                 ${D}(%d skills)${N}\n" "$skill_count"
    while IFS= read -r skill_file; do
      skill_name=$(basename "$(dirname "$skill_file")")
      printf "    ${A}%s${N}\n" "$skill_name"
    done < <(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | sort)
  fi

  # Global hooks
  if [[ -f "$HOME/.claude/settings.json" ]] && grep -q '"hooks"' "$HOME/.claude/settings.json" 2>/dev/null; then
    printf "  ${G}●${N} Global Claude hooks           ${D}(active)${N}\n"
  else
    printf "  ${R}●${N} Global Claude hooks           ${D}(none)${N}\n"
  fi
}

# ============================================================
# GAPS — show projects missing key infrastructure
# ============================================================
cmd_gaps() {
  section "Projects Missing Infrastructure"

  local missing_claude=()
  local missing_git=()
  local missing_hook=()
  local missing_credo=()
  local missing_precommit=()
  local missing_ci=()

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Skip non-code directories
    [[ -d "$proj_dir/.git" ]] || [[ -f "$proj_dir/mix.exs" ]] || [[ -f "$proj_dir/package.json" ]] || continue

    # Universal checks
    if [[ ! -f "$proj_dir/CLAUDE.md" ]]; then
      missing_claude+=("$proj")
    fi
    if [[ ! -d "$proj_dir/.git" ]]; then
      missing_git+=("$proj")
    fi

    # Git hook check
    if [[ -d "$proj_dir/.git" ]] && [[ ! -x "$proj_dir/.git/hooks/pre-commit" ]]; then
      missing_hook+=("$proj")
    fi

    # Elixir-specific checks
    if [[ -f "$proj_dir/mix.exs" ]]; then
      if ! grep -q "credo" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_credo+=("$proj")
      fi
      if ! grep -q "precommit" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_precommit+=("$proj")
      fi
    fi

    # CI/CD check
    if [[ -d "$proj_dir/.git" ]]; then
      has_ci=false
      [[ -d "$proj_dir/.github/workflows" ]] && has_ci=true
      [[ -f "$proj_dir/.gitlab-ci.yml" ]] && has_ci=true
      if ! $has_ci; then
        missing_ci+=("$proj")
      fi
    fi
  done

  # Production readiness checks — only for projects with CI (they're production-bound)
  local missing_release=()
  local missing_health=()
  local missing_deploy=()
  local missing_backup=()
  local missing_errortracking=()
  local missing_envtemplate=()

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Only check projects that have CI
    local has_ci=false
    [[ -d "$proj_dir/.github/workflows" ]] && has_ci=true
    [[ -f "$proj_dir/.gitlab-ci.yml" ]] && has_ci=true
    $has_ci || continue

    # Release module (Elixir-specific) — check root and server/ for monorepos
    if [[ -f "$proj_dir/mix.exs" ]] || [[ -f "$proj_dir/server/mix.exs" ]]; then
      if ! grep -rq "Release" "$proj_dir"/lib/*/release.ex "$proj_dir"/server/lib/*/release.ex 2>/dev/null; then
        missing_release+=("$proj")
      fi
    fi

    # Health endpoint — check lib/, server/lib/, src/ for monorepos
    if ! grep -rq '/health\|/api/health' "$proj_dir/lib/" "$proj_dir/server/lib/" "$proj_dir/src/" 2>/dev/null; then
      missing_health+=("$proj")
    fi

    # Deploy scripts
    if [[ ! -d "$proj_dir/deploy" ]] && [[ ! -f "$proj_dir/graybeam.toml" ]]; then
      missing_deploy+=("$proj")
    fi

    # Backup script
    if [[ ! -f "$proj_dir/deploy/backup.sh" ]] && ! grep -q "backup" "$proj_dir/graybeam.toml" 2>/dev/null; then
      missing_backup+=("$proj")
    fi

    # Error tracking — check root and subdirs for monorepos
    if ! grep -rq 'sentry\|Sentry\|rollbar\|bugsnag' "$proj_dir/mix.exs" "$proj_dir/server/mix.exs" "$proj_dir/package.json" "$proj_dir/frontend/package.json" "$proj_dir/Cargo.toml" 2>/dev/null; then
      missing_errortracking+=("$proj")
    fi

    # Env template
    if [[ ! -f "$proj_dir/.env.example" ]] && [[ ! -f "$proj_dir/deploy/provision.sh" ]]; then
      missing_envtemplate+=("$proj")
    fi
  done

  # Report each category
  if (( ${#missing_claude[@]} > 0 )); then
    printf "  ${Y}No CLAUDE.md:${N}\n"
    for p in "${missing_claude[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_git[@]} > 0 )); then
    printf "  ${Y}No git repo:${N}\n"
    for p in "${missing_git[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_hook[@]} > 0 )); then
    printf "  ${Y}No pre-commit hook:${N}\n"
    for p in "${missing_hook[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_credo[@]} > 0 )); then
    printf "  ${Y}Elixir without Credo:${N}\n"
    for p in "${missing_credo[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_precommit[@]} > 0 )); then
    printf "  ${Y}Elixir without mix precommit:${N}\n"
    for p in "${missing_precommit[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_ci[@]} > 0 )); then
    printf "  ${Y}No CI/CD pipeline:${N}\n"
    for p in "${missing_ci[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  # Production readiness report (only if any CI projects exist)
  local prod_gaps=$(( ${#missing_release[@]} + ${#missing_health[@]} + ${#missing_deploy[@]} + ${#missing_backup[@]} + ${#missing_errortracking[@]} + ${#missing_envtemplate[@]} ))
  if (( prod_gaps > 0 )); then
    section "Production Readiness (projects with CI)"

    if (( ${#missing_release[@]} > 0 )); then
      printf "  ${Y}Elixir without Release module:${N}\n"
      for p in "${missing_release[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_health[@]} > 0 )); then
      printf "  ${Y}No health endpoint:${N}\n"
      for p in "${missing_health[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_deploy[@]} > 0 )); then
      printf "  ${Y}No deploy scripts:${N}\n"
      for p in "${missing_deploy[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_backup[@]} > 0 )); then
      printf "  ${Y}No backup script:${N}\n"
      for p in "${missing_backup[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_errortracking[@]} > 0 )); then
      printf "  ${Y}No error tracking:${N}\n"
      for p in "${missing_errortracking[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi

    if (( ${#missing_envtemplate[@]} > 0 )); then
      printf "  ${Y}No .env template:${N}\n"
      for p in "${missing_envtemplate[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
      printf "\n"
    fi
  fi

  # Summary
  local total_gaps=$(( ${#missing_claude[@]} + ${#missing_hook[@]} + ${#missing_credo[@]} + ${#missing_precommit[@]} + ${#missing_ci[@]} + prod_gaps ))
  if (( total_gaps == 0 )); then
    printf "  ${G}All projects have full quality and production infrastructure.${N}\n"
  else
    local dev_gaps=$(( ${#missing_claude[@]} + ${#missing_hook[@]} + ${#missing_credo[@]} + ${#missing_precommit[@]} + ${#missing_ci[@]} ))
    printf "  ${D}Dev quality gaps: %d | Production readiness gaps: %d${N}\n" "$dev_gaps" "$prod_gaps"
    printf "  ${D}Fix with: trimtab init <project>${N}\n"
  fi
}

# ============================================================
# SYNC — extract and propagate lessons across projects
# ============================================================
cmd_sync() {
  local use_ai=false
  for arg in "$@"; do
    [[ "$arg" == "--ai" ]] && use_ai=true
  done

  section "Cross-Project Lesson Extraction"

  # Collect all pitfalls, gotchas, known issues, and lessons from CLAUDE.md files
  local all_lessons=""
  local project_count=0
  local lesson_count=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    local proj=$(basename "$proj_dir")
    local claude_file="$proj_dir/CLAUDE.md"
    [[ -f "$claude_file" ]] || continue

    # Extract sections: Common Pitfalls, Known Issues, Critical Gotchas, Errors & Lessons
    local extracted=""
    extracted=$(awk '
      /^##+ .*(Pitfall|Gotcha|Known Issue|Known Problem|Errors|Lesson|Regression|Warning)/ { capture=1; next }
      /^##+ / { capture=0 }
      capture && /^[[:space:]]*[-*]/ { print }
    ' "$claude_file" 2>/dev/null)

    if [[ -n "$extracted" ]]; then
      local count
      count=$(echo "$extracted" | wc -l)
      lesson_count=$((lesson_count + count))
      project_count=$((project_count + 1))
      printf "  ${G}●${N} %-24s ${D}%d lessons${N}\n" "$proj" "$count"
      all_lessons+="
## ${proj}
${extracted}
"
    fi
  done

  # Also extract from memory files
  section "Memory File Lessons"
  local memory_lessons=""

  for memory_dir in "$HOME/.claude/projects/-${CHEZMOI_PREFIX}-"*/memory/; do
    [[ -d "$memory_dir" ]] || continue
    local proj
    proj=$(basename "$(dirname "$memory_dir")")
    proj="${proj#-${CHEZMOI_PREFIX}-}"

    for md_file in "$memory_dir"*.md; do
      [[ -f "$md_file" ]] || continue

      local extracted=""
      extracted=$(awk '
        /^##+ .*(Lesson|Error|Pitfall|Mistake|Regression|Fix|Warning|Concern|Bug)/ { capture=1; next }
        /^##+ / { capture=0 }
        capture && /^[[:space:]]*[-*]/ { print }
      ' "$md_file" 2>/dev/null)

      if [[ -n "$extracted" ]]; then
        local count
        count=$(echo "$extracted" | wc -l)
        lesson_count=$((lesson_count + count))
        printf "  ${G}●${N} %-24s ${D}%d lessons${N}\n" "$proj/$(basename "$md_file")" "$count"
        memory_lessons+="
## ${proj} (memory)
${extracted}
"
      fi
    done
  done

  # Check what's already in global CLAUDE.md
  local global_lessons=""
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    global_lessons=$(awk '
      /^##+ .*(Safe Deletion|Safe Process|Debug|Pushback|Enforcement|Pitfall|Lesson)/ { capture=1; next }
      /^##+ / { capture=0 }
      capture && /^[[:space:]]*[-*]/ { print }
    ' "$HOME/.claude/CLAUDE.md" 2>/dev/null)
  fi

  local global_count=0
  [[ -n "$global_lessons" ]] && global_count=$(echo "$global_lessons" | wc -l)

  section "Summary"
  printf "  ${D}Projects with documented lessons:${N} %d\n" "$project_count"
  printf "  ${D}Total lessons extracted:${N}          %d\n" "$lesson_count"
  printf "  ${D}Global CLAUDE.md rules:${N}           %d\n" "$global_count"

  # Without --ai, just show the raw extraction
  if ! $use_ai; then
    if (( lesson_count > 0 )); then
      section "All Extracted Lessons"
      echo "$all_lessons" | while IFS= read -r line; do
        if [[ "$line" =~ ^##\  ]]; then
          printf "\n  ${C}%s${N}\n" "${line## }"
        elif [[ -n "$line" ]]; then
          printf "  %s\n" "$line"
        fi
      done
      if [[ -n "$memory_lessons" ]]; then
        echo "$memory_lessons" | while IFS= read -r line; do
          if [[ "$line" =~ ^##\  ]]; then
            printf "\n  ${C}%s${N}\n" "${line## }"
          elif [[ -n "$line" ]]; then
            printf "  %s\n" "$line"
          fi
        done
      fi
      printf "\n  ${D}Run 'trimtab steer sync --ai' for AI-powered pattern analysis${N}\n"
    fi
    return
  fi

  # ── AI-powered analysis ──
  section "AI Pattern Analysis"
  printf "  ${D}Analyzing %d lessons across %d projects...${N}\n" "$lesson_count" "$project_count"

  # Find API key
  local api_key
  api_key=$(_find_openrouter_key)

  if [[ -z "$api_key" ]]; then
    printf "  ${R}No OPENROUTER_API_KEY found${N}\n"
    return 1
  fi

  local prompt="/no_think
You are analyzing lessons learned and common pitfalls extracted from CLAUDE.md files and memory files across ${project_count} software projects.

## Project Lessons
${all_lessons}
${memory_lessons}

## Currently in Global CLAUDE.md
${global_lessons}

Your task:
1. IDENTIFY cross-cutting patterns — lessons that appear in 2+ projects or apply universally
2. FLAG lessons that are NOT yet in the global CLAUDE.md but should be
3. DEDUPLICATE — merge similar lessons into concise rules
4. CATEGORIZE as: [PROMOTE TO GLOBAL] [PROJECT-SPECIFIC] [ALREADY GLOBAL]

Format your response as:

### Promote to Global CLAUDE.md
- [lesson] — appears in: [project1, project2]

### Cross-Cutting Patterns
- [pattern description] — affected projects: [list]

### Project-Specific (leave in place)
- [project]: [lesson summary]

Be concise. Focus on actionable rules, not descriptions."

  local payload
  payload=$(python3 -c "
import json, sys
print(json.dumps({
    'model': 'qwen/qwen3-32b',
    'messages': [{'role': 'user', 'content': sys.argv[1]}],
    'max_tokens': 2000,
    'temperature': 0.3
}))
" "$prompt")

  local response
  response=$(curl -s -X POST "https://openrouter.ai/api/v1/chat/completions" \
    -H "Authorization: Bearer $api_key" \
    -H "Content-Type: application/json" \
    -d "$payload" 2>/dev/null)

  local content
  content=$(echo "$response" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(data['choices'][0]['message']['content'])
except Exception as e:
    print(f'Error parsing response: {e}')
" 2>/dev/null)

  if [[ -n "$content" ]]; then
    printf "\n"
    echo "$content" | while IFS= read -r line; do
      if [[ "$line" =~ ^###\  ]]; then
        printf "  ${B}${C}%s${N}\n" "$line"
      elif [[ "$line" =~ ^-\  ]]; then
        printf "  %s\n" "$line"
      elif [[ -n "$line" ]]; then
        printf "  ${D}%s${N}\n" "$line"
      fi
    done
    printf "\n  ${D}Review above and add relevant items to ~/.claude/CLAUDE.md${N}\n"
  else
    printf "  ${R}Empty response from AI${N}\n"
  fi
}

# ============================================================
# UX — audit LiveView UX anti-patterns across projects
# ============================================================
cmd_ux() {
  local filter_project="${1:-}"

  section "UX Pattern Audit (LiveView Projects)"

  local total_issues=0
  local projects_scanned=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    local proj
    proj=$(basename "$proj_dir")

    # If filtering to a single project, skip others
    if [[ -n "$filter_project" ]] && [[ "$proj" != "$filter_project" ]]; then
      continue
    fi

    # Only LiveView projects
    [[ -f "$proj_dir/mix.exs" ]] || continue
    grep -q "phoenix_live_view\|phoenix_html" "$proj_dir/mix.exs" 2>/dev/null || continue

    projects_scanned=$((projects_scanned + 1))
    local proj_issues=()

    # Find .heex files, excluding deps/_build/_archive/error_html
    local heex_files=()
    while IFS= read -r -d '' f; do
      heex_files+=("$f")
    done < <(find "$proj_dir/lib" -name "*.heex" \
      -not -path "*/deps/*" \
      -not -path "*/_build/*" \
      -not -path "*/_archive/*" \
      -not -path "*/error_html/*" \
      -print0 2>/dev/null)

    # Check 1: Raw <a href= (should be <.link navigate=)
    local raw_links=()
    for file in "${heex_files[@]}"; do
      local matches
      matches=$(grep -n '<a[[:space:]]\+href=' "$file" 2>/dev/null \
        | grep -v 'href="https\?://' \
        | grep -v 'href="#' || true)
      if [[ -n "$matches" ]]; then
        while IFS= read -r line; do
          local relpath="${file#"$proj_dir"}"
          local lineno="${line%%:*}"
          raw_links+=("${relpath}:${lineno}")
        done <<< "$matches"
      fi
    done

    if (( ${#raw_links[@]} > 0 )); then
      proj_issues+=("RAW_LINKS")
    fi

    # Check 2: <button type="submit"> without phx-disable-with
    local no_disable=()
    for file in "${heex_files[@]}"; do
      local matches
      matches=$(grep -n 'type="submit"' "$file" 2>/dev/null \
        | grep -v 'phx-disable-with' || true)
      if [[ -n "$matches" ]]; then
        while IFS= read -r line; do
          local relpath="${file#"$proj_dir"}"
          local lineno="${line%%:*}"
          no_disable+=("${relpath}:${lineno}")
        done <<< "$matches"
      fi
    done

    if (( ${#no_disable[@]} > 0 )); then
      proj_issues+=("NO_DISABLE_WITH")
    fi

    # Check 3: Uses phx-click but missing CSS loading variants
    local has_phx_click=false
    local has_loading_css=false
    for file in "${heex_files[@]}"; do
      if grep -q 'phx-click=' "$file" 2>/dev/null; then
        has_phx_click=true
        break
      fi
    done

    if $has_phx_click; then
      local css_file="$proj_dir/assets/css/app.css"
      if [[ -f "$css_file" ]]; then
        if grep -q 'phx-click-loading\|@custom-variant' "$css_file" 2>/dev/null; then
          has_loading_css=true
        fi
      fi
    fi

    local missing_loading=false
    if $has_phx_click && ! $has_loading_css; then
      missing_loading=true
      proj_issues+=("MISSING_LOADING_CSS")
    fi

    # Check 4: phx-change on bare <input>/<select>/<textarea> outside a <form>
    local bare_phx_change=()
    for file in "${heex_files[@]}"; do
      local matches
      matches=$(grep -n 'phx-change=' "$file" 2>/dev/null || true)
      [[ -z "$matches" ]] && continue
      while IFS= read -r line; do
        # Skip if the line contains <form (it's on the form itself)
        echo "$line" | grep -q '<form' && continue
        # Flag input/select/textarea with phx-change
        if echo "$line" | grep -qE '<(input|select|textarea)[[:space:]]' 2>/dev/null; then
          local relpath="${file#"$proj_dir"}"
          local lineno="${line%%:*}"
          bare_phx_change+=("${relpath}:${lineno}")
        fi
      done <<< "$matches"
    done

    if (( ${#bare_phx_change[@]} > 0 )); then
      proj_issues+=("BARE_PHX_CHANGE")
    fi

    # Check 5: :utc_datetime without _usec in migrations
    local bad_datetime=()
    while IFS= read -r -d '' migfile; do
      local matches
      matches=$(grep -n ':utc_datetime' "$migfile" 2>/dev/null | grep -v '_usec' || true)
      if [[ -n "$matches" ]]; then
        while IFS= read -r line; do
          local relpath="${migfile#"$proj_dir"}"
          local lineno="${line%%:*}"
          bad_datetime+=("${relpath}:${lineno}")
        done <<< "$matches"
      fi
    done < <(find "$proj_dir" -path "*/migrations/*.exs" -not -path "*/deps/*" -not -path "*/_build/*" -print0 2>/dev/null)

    if (( ${#bad_datetime[@]} > 0 )); then
      proj_issues+=("UTC_DATETIME")
    fi

    # Check 6: <textarea value= (browsers ignore it)
    local textarea_value=()
    for file in "${heex_files[@]}"; do
      local matches
      matches=$(grep -n '<textarea[[:space:]].*value=' "$file" 2>/dev/null || true)
      if [[ -n "$matches" ]]; then
        while IFS= read -r line; do
          local relpath="${file#"$proj_dir"}"
          local lineno="${line%%:*}"
          textarea_value+=("${relpath}:${lineno}")
        done <<< "$matches"
      fi
    done

    if (( ${#textarea_value[@]} > 0 )); then
      proj_issues+=("TEXTAREA_VALUE")
    fi

    # Check 7: Missing catch-all handle_event
    local missing_catchall=()
    local ex_files=()
    while IFS= read -r -d '' f; do
      ex_files+=("$f")
    done < <(find "$proj_dir/lib" -name "*.ex" -not -path "*/deps/*" -not -path "*/_build/*" -print0 2>/dev/null)

    for file in "${ex_files[@]}"; do
      # Only check files that define handle_event
      grep -q 'def handle_event(' "$file" 2>/dev/null || continue
      # Check if a catch-all exists (matches any event name with _ or variable)
      if ! grep -qE 'def handle_event\(\s*(_|[a-z_]+)\s*,\s*(_|_[a-z_]*)\s*,\s*socket\)' "$file" 2>/dev/null; then
        local relpath="${file#"$proj_dir"}"
        missing_catchall+=("$relpath")
      fi
    done

    if (( ${#missing_catchall[@]} > 0 )); then
      proj_issues+=("MISSING_CATCHALL")
    fi

    # Print project results if it has issues
    if (( ${#proj_issues[@]} > 0 )); then
      printf "\n  ${B}%s${N}\n" "$proj"

      if (( ${#raw_links[@]} > 0 )); then
        printf "    ${Y}●${N} Raw <a href=...> — use <.link navigate=...>\n"
        for loc in "${raw_links[@]}"; do
          printf "      ${D}%s${N}\n" "$loc"
        done
        total_issues=$((total_issues + ${#raw_links[@]}))
      fi

      if (( ${#no_disable[@]} > 0 )); then
        printf "    ${Y}●${N} <button type=\"submit\"> without phx-disable-with\n"
        for loc in "${no_disable[@]}"; do
          printf "      ${D}%s${N}\n" "$loc"
        done
        total_issues=$((total_issues + ${#no_disable[@]}))
      fi

      if $missing_loading; then
        printf "    ${Y}●${N} Uses phx-click but missing CSS @custom-variant for loading states\n"
        total_issues=$((total_issues + 1))
      fi

      if (( ${#bare_phx_change[@]} > 0 )); then
        printf "    ${Y}●${N} phx-change on bare <input> outside <form>\n"
        for loc in "${bare_phx_change[@]}"; do
          printf "      ${D}%s${N}\n" "$loc"
        done
        total_issues=$((total_issues + ${#bare_phx_change[@]}))
      fi

      if (( ${#bad_datetime[@]} > 0 )); then
        printf "    ${Y}●${N} :utc_datetime without _usec in migration\n"
        for loc in "${bad_datetime[@]}"; do
          printf "      ${D}%s${N}\n" "$loc"
        done
        total_issues=$((total_issues + ${#bad_datetime[@]}))
      fi

      if (( ${#textarea_value[@]} > 0 )); then
        printf "    ${Y}●${N} <textarea value=...> — browsers ignore value attr on textarea\n"
        for loc in "${textarea_value[@]}"; do
          printf "      ${D}%s${N}\n" "$loc"
        done
        total_issues=$((total_issues + ${#textarea_value[@]}))
      fi

      if (( ${#missing_catchall[@]} > 0 )); then
        printf "    ${Y}●${N} handle_event without catch-all clause (crash loop risk)\n"
        for loc in "${missing_catchall[@]}"; do
          printf "      ${D}%s${N}\n" "$loc"
        done
        total_issues=$((total_issues + ${#missing_catchall[@]}))
      fi
    fi
  done

  # Summary
  section "Summary"
  printf "  ${D}Projects scanned: %d | Issues: %d${N}\n" "$projects_scanned" "$total_issues"

  if (( total_issues == 0 )); then
    printf "  ${G}No UX anti-patterns found.${N}\n"
  fi
}

# ============================================================
# DISPATCH
# ============================================================
case "$CMD" in
  audit)  cmd_audit ;;
  gaps)   cmd_gaps ;;
  sync)   cmd_sync "$@" ;;
  ux)     cmd_ux "$@" ;;
  *)
    echo "trimtab steer — manage trim tab infrastructure"
    echo ""
    echo "Usage: trimtab steer [command]"
    echo ""
    echo "Commands:"
    echo "  audit    Show trim tab infrastructure across all projects (default)"
    echo "  gaps     Show projects missing key infrastructure"
    echo "  sync     Extract and propagate lessons across projects (--ai for analysis)"
    echo "  ux       Audit LiveView UX anti-patterns (raw links, missing disable-with, etc.)"
    ;;
esac
