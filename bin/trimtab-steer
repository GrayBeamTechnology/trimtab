#!/usr/bin/env bash
# trimtab steer — audit and manage trim tab infrastructure across projects
# Shows CLAUDE.md, memory files, skills, quality tools, and config drift
set -euo pipefail

R=$'\033[0;31m'   G=$'\033[0;32m'   D=$'\033[2m'
B=$'\033[1m'      C=$'\033[0;36m'   Y=$'\033[0;33m'
A=$'\033[0;33m'   N=$'\033[0m'

PROJECTS_DIR="$HOME/1-Projects"
CMD="${1:-audit}"

section() { printf "\n${B}${C}── %s${N}\n" "$1"; }

# ============================================================
# AUDIT — show trim tab infrastructure across all projects
# ============================================================
cmd_audit() {
  section "Trim Tab Infrastructure"
  printf "  ${D}%-22s %s %s %s %s %s %s${N}\n" "PROJECT" "CLAUDE" "MEMORY" "SKILL" "TASKS" "GIT" "DESIGN"
  printf "  ${D}%-22s %s %s %s %s %s %s${N}\n" "───────" "──────" "──────" "─────" "─────" "───" "──────"

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Check for each trim tab
    has_claude="  ${D}·${N} "
    has_memory="  ${D}·${N} "
    has_skills="  ${D}·${N} "
    has_tasks="  ${D}·${N} "
    has_git="  ${D}·${N} "

    # CLAUDE.md — check root and .claude/
    if [[ -f "$proj_dir/CLAUDE.md" ]]; then
      lines=$(wc -l < "$proj_dir/CLAUDE.md")
      has_claude="${G}${lines}L${N}"
      has_claude=$(printf "%-6s" "$has_claude")
    fi

    # Memory files
    memory_dir="$HOME/.claude/projects/-home-mchughson-1-Projects-${proj}/memory"
    if [[ -d "$memory_dir" ]]; then
      mcount=$(find "$memory_dir" -name "*.md" 2>/dev/null | wc -l)
      if (( mcount > 0 )); then
        has_memory="${G}${mcount}${N}   "
      fi
    fi

    # Skills — check project-level .claude/skills/
    if [[ -d "$proj_dir/.claude/skills" ]]; then
      scount=$(find "$proj_dir/.claude/skills" -name "*.md" 2>/dev/null | wc -l)
      if (( scount > 0 )); then
        has_skills="${G}${scount}${N}  "
      fi
    fi

    # Task Master
    if [[ -f "$proj_dir/.taskmaster/tasks/tasks.json" ]]; then
      has_tasks="${G}yes${N}"
      has_tasks=$(printf "%-5s" "$has_tasks")
    fi

    # Git
    if [[ -d "$proj_dir/.git" ]]; then
      has_git="${G}yes${N}"
    fi

    # Design system (graybeam-ui tokens)
    has_design="  ${D}·${N} "
    if [[ -d "$proj_dir/assets/vendor/graybeam-ui" ]]; then
      has_design="${G}yes${N}  "
    elif [[ ! -d "$proj_dir/assets" ]] && [[ ! -d "$proj_dir/src" ]]; then
      has_design="${D}n/a${N}  "
    fi

    printf "  %-22s %s %s %s %s %s %s\n" "$proj" "$has_claude" "$has_memory" "$has_skills" "$has_tasks" "$has_git" "$has_design"
  done

  # Global trim tabs
  section "Global Trim Tabs"
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    lines=$(wc -l < "$HOME/.claude/CLAUDE.md")
    printf "  ${G}●${N} ~/.claude/CLAUDE.md          ${D}(%d lines)${N}\n" "$lines"
  fi

  global_memory="$HOME/.claude/projects/-home-mchughson-1-Projects/memory"
  if [[ -d "$global_memory" ]]; then
    mcount=$(find "$global_memory" -name "*.md" 2>/dev/null | wc -l)
    printf "  ${G}●${N} Global memory files           ${D}(%d files)${N}\n" "$mcount"
  fi

  skill_count=$(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | wc -l)
  if (( skill_count > 0 )); then
    printf "  ${G}●${N} Global skills                 ${D}(%d skills)${N}\n" "$skill_count"
    while IFS= read -r skill_file; do
      skill_name=$(basename "$(dirname "$skill_file")")
      printf "    ${A}%s${N}\n" "$skill_name"
    done < <(find "$HOME/.claude/skills" -name "SKILL.md" 2>/dev/null | sort)
  fi

  # Global hooks — enumerate each one
  if [[ -f "$HOME/.claude/settings.json" ]] && grep -q '"hooks"' "$HOME/.claude/settings.json" 2>/dev/null; then
    hook_count=$(python3 -c "
import json, sys
try:
    data = json.load(open('$HOME/.claude/settings.json'))
    hooks = data.get('hooks', {})
    count = 0
    for event, matchers in hooks.items():
        for m in matchers:
            for h in m.get('hooks', []):
                count += 1
    print(count)
except: print(0)
" 2>/dev/null)
    printf "  ${G}●${N} Global Claude hooks           ${D}(%s hooks)${N}\n" "$hook_count"
    python3 -c "
import json, os
try:
    data = json.load(open('$HOME/.claude/settings.json'))
    hooks = data.get('hooks', {})
    for event, matchers in hooks.items():
        for m in matchers:
            tool = m.get('matcher', '?')
            for h in m.get('hooks', []):
                name = os.path.basename(h.get('command', '?')).replace('.sh','')
                print(f'    {event}:{tool} → {name}')
except: pass
" 2>/dev/null
  else
    printf "  ${R}●${N} Global Claude hooks           ${D}(none)${N}\n"
  fi

  # Check for project-level hook shadowing
  local shadow_count=0
  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    local proj_settings="$proj_dir/.claude/settings.json"
    if [[ -f "$proj_settings" ]] && grep -q '"hooks"' "$proj_settings" 2>/dev/null; then
      proj=$(basename "$proj_dir")
      if (( shadow_count == 0 )); then
        printf "\n  ${Y}⚠ Projects with local hook overrides:${N}\n"
      fi
      printf "    ${Y}●${N} %s\n" "$proj"
      shadow_count=$((shadow_count + 1))
    fi
  done
}

# ============================================================
# GAPS — show projects missing key infrastructure
# ============================================================
cmd_gaps() {
  section "Projects Missing Infrastructure"

  local missing_claude=()
  local missing_git=()
  local missing_hook=()
  local missing_credo=()
  local missing_precommit=()
  local missing_ci=()
  local missing_design=()
  local hook_shadows=()

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    proj=$(basename "$proj_dir")

    # Skip non-code directories
    [[ -d "$proj_dir/.git" ]] || [[ -f "$proj_dir/mix.exs" ]] || [[ -f "$proj_dir/package.json" ]] || continue

    # Universal checks
    if [[ ! -f "$proj_dir/CLAUDE.md" ]]; then
      missing_claude+=("$proj")
    fi
    if [[ ! -d "$proj_dir/.git" ]]; then
      missing_git+=("$proj")
    fi

    # Git hook check
    if [[ -d "$proj_dir/.git" ]] && [[ ! -x "$proj_dir/.git/hooks/pre-commit" ]]; then
      missing_hook+=("$proj")
    fi

    # Elixir-specific checks
    if [[ -f "$proj_dir/mix.exs" ]]; then
      if ! grep -q "credo" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_credo+=("$proj")
      fi
      if ! grep -q "precommit" "$proj_dir/mix.exs" 2>/dev/null; then
        missing_precommit+=("$proj")
      fi
    fi

    # CI/CD check
    if [[ -d "$proj_dir/.git" ]]; then
      has_ci=false
      [[ -d "$proj_dir/.github/workflows" ]] && has_ci=true
      [[ -f "$proj_dir/.gitlab-ci.yml" ]] && has_ci=true
      if ! $has_ci; then
        missing_ci+=("$proj")
      fi
    fi

    # Design system check (only for UI projects)
    if [[ -d "$proj_dir/assets" ]] || [[ -d "$proj_dir/src" ]]; then
      if [[ ! -d "$proj_dir/assets/vendor/graybeam-ui" ]]; then
        missing_design+=("$proj")
      fi
    fi

    # Hook shadow check (project settings defining hooks that override global)
    local proj_settings="$proj_dir/.claude/settings.json"
    if [[ -f "$proj_settings" ]] && grep -q '"hooks"' "$proj_settings" 2>/dev/null; then
      hook_shadows+=("$proj")
    fi
  done

  # Report each category
  if (( ${#missing_claude[@]} > 0 )); then
    printf "  ${Y}No CLAUDE.md:${N}\n"
    for p in "${missing_claude[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_git[@]} > 0 )); then
    printf "  ${Y}No git repo:${N}\n"
    for p in "${missing_git[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_hook[@]} > 0 )); then
    printf "  ${Y}No pre-commit hook:${N}\n"
    for p in "${missing_hook[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_credo[@]} > 0 )); then
    printf "  ${Y}Elixir without Credo:${N}\n"
    for p in "${missing_credo[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_precommit[@]} > 0 )); then
    printf "  ${Y}Elixir without mix precommit:${N}\n"
    for p in "${missing_precommit[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_ci[@]} > 0 )); then
    printf "  ${Y}No CI/CD pipeline:${N}\n"
    for p in "${missing_ci[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#missing_design[@]} > 0 )); then
    printf "  ${Y}No graybeam-ui tokens:${N}\n"
    for p in "${missing_design[@]}"; do printf "    ${R}●${N} %s\n" "$p"; done
    printf "\n"
  fi

  if (( ${#hook_shadows[@]} > 0 )); then
    printf "  ${D}Projects with local hooks (additive to global — not a gap):${N}\n"
    for p in "${hook_shadows[@]}"; do printf "    ${D}ℹ${N} %s\n" "$p"; done
    printf "\n"
  fi

  # Global hook health check
  local hook_issues=0
  if [[ -f "$HOME/.claude/settings.json" ]]; then
    local missing_scripts
    missing_scripts=$(python3 -c "
import json, os
try:
    data = json.load(open('$HOME/.claude/settings.json'))
    hooks = data.get('hooks', {})
    missing = []
    for event, matchers in hooks.items():
        for m in matchers:
            for h in m.get('hooks', []):
                cmd = h.get('command', '')
                if cmd and not os.path.isfile(cmd):
                    missing.append(os.path.basename(cmd))
                elif cmd and not os.access(cmd, os.X_OK):
                    missing.append(os.path.basename(cmd) + ' (not executable)')
    for m in missing:
        print(m)
except: pass
" 2>/dev/null)
    if [[ -n "$missing_scripts" ]]; then
      printf "  ${R}Broken global hooks:${N}\n"
      while IFS= read -r script; do
        printf "    ${R}●${N} %s\n" "$script"
        hook_issues=$((hook_issues + 1))
      done <<< "$missing_scripts"
      printf "\n"
    fi
  else
    printf "  ${R}No global Claude settings (~/.claude/settings.json missing)${N}\n"
    hook_issues=1
  fi

  # Summary
  local total_gaps=$(( ${#missing_claude[@]} + ${#missing_hook[@]} + ${#missing_credo[@]} + ${#missing_precommit[@]} + ${#missing_ci[@]} + ${#missing_design[@]} + hook_issues ))
  if (( total_gaps == 0 )); then
    printf "  ${G}All projects have full quality infrastructure.${N}\n"
  else
    printf "  ${D}Total gaps: %d across all categories${N}\n" "$total_gaps"
    printf "  ${D}Fix with: trimtab init <project>${N}\n"
  fi
}

# ============================================================
# SYNC — extract and propagate lessons across projects
# ============================================================
cmd_sync() {
  local use_ai=false
  shift 2>/dev/null || true
  for arg in "$@"; do
    [[ "$arg" == "--ai" ]] && use_ai=true
  done

  section "Cross-Project Lesson Extraction"

  # Collect all pitfalls, gotchas, known issues, and lessons from CLAUDE.md files
  local all_lessons=""
  local project_count=0
  local lesson_count=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    local proj=$(basename "$proj_dir")
    local claude_file="$proj_dir/CLAUDE.md"
    [[ -f "$claude_file" ]] || continue

    # Extract sections: Common Pitfalls, Known Issues, Critical Gotchas, Errors & Lessons
    local extracted=""
    extracted=$(awk '
      /^##+ .*(Pitfall|Gotcha|Known Issue|Known Problem|Errors|Lesson|Regression|Warning)/ { capture=1; next }
      /^##+ / { capture=0 }
      capture && /^[[:space:]]*[-*]/ { print }
    ' "$claude_file" 2>/dev/null)

    if [[ -n "$extracted" ]]; then
      local count
      count=$(echo "$extracted" | wc -l)
      lesson_count=$((lesson_count + count))
      project_count=$((project_count + 1))
      printf "  ${G}●${N} %-24s ${D}%d lessons${N}\n" "$proj" "$count"
      all_lessons+="
## ${proj}
${extracted}
"
    fi
  done

  # Also extract from memory files
  section "Memory File Lessons"
  local memory_lessons=""

  for memory_dir in "$HOME/.claude/projects/-home-mchughson-1-Projects-"*/memory/; do
    [[ -d "$memory_dir" ]] || continue
    local proj
    proj=$(basename "$(dirname "$memory_dir")")
    proj="${proj#-home-mchughson-1-Projects-}"

    for md_file in "$memory_dir"*.md; do
      [[ -f "$md_file" ]] || continue

      local extracted=""
      extracted=$(awk '
        /^##+ .*(Lesson|Error|Pitfall|Mistake|Regression|Fix|Warning|Concern|Bug)/ { capture=1; next }
        /^##+ / { capture=0 }
        capture && /^[[:space:]]*[-*]/ { print }
      ' "$md_file" 2>/dev/null)

      if [[ -n "$extracted" ]]; then
        local count
        count=$(echo "$extracted" | wc -l)
        lesson_count=$((lesson_count + count))
        printf "  ${G}●${N} %-24s ${D}%d lessons${N}\n" "$proj/$(basename "$md_file")" "$count"
        memory_lessons+="
## ${proj} (memory)
${extracted}
"
      fi
    done
  done

  # Check what's already in global CLAUDE.md
  local global_lessons=""
  if [[ -f "$HOME/.claude/CLAUDE.md" ]]; then
    global_lessons=$(awk '
      /^##+ .*(Safe Deletion|Safe Process|Debug|Pushback|Enforcement|Pitfall|Lesson)/ { capture=1; next }
      /^##+ / { capture=0 }
      capture && /^[[:space:]]*[-*]/ { print }
    ' "$HOME/.claude/CLAUDE.md" 2>/dev/null)
  fi

  local global_count=0
  [[ -n "$global_lessons" ]] && global_count=$(echo "$global_lessons" | wc -l)

  section "Summary"
  printf "  ${D}Projects with documented lessons:${N} %d\n" "$project_count"
  printf "  ${D}Total lessons extracted:${N}          %d\n" "$lesson_count"
  printf "  ${D}Global CLAUDE.md rules:${N}           %d\n" "$global_count"

  # Without --ai, just show the raw extraction
  if ! $use_ai; then
    if (( lesson_count > 0 )); then
      section "All Extracted Lessons"
      echo "$all_lessons" | while IFS= read -r line; do
        if [[ "$line" =~ ^##\  ]]; then
          printf "\n  ${C}%s${N}\n" "${line## }"
        elif [[ -n "$line" ]]; then
          printf "  %s\n" "$line"
        fi
      done
      if [[ -n "$memory_lessons" ]]; then
        echo "$memory_lessons" | while IFS= read -r line; do
          if [[ "$line" =~ ^##\  ]]; then
            printf "\n  ${C}%s${N}\n" "${line## }"
          elif [[ -n "$line" ]]; then
            printf "  %s\n" "$line"
          fi
        done
      fi
      printf "\n  ${D}Run 'trimtab steer sync --ai' for AI-powered pattern analysis${N}\n"
    fi
    return
  fi

  # ── AI-powered analysis ──
  section "AI Pattern Analysis"
  printf "  ${D}Analyzing %d lessons across %d projects...${N}\n" "$lesson_count" "$project_count"

  # Find API key
  local api_key=""
  for env_file in "$PROJECTS_DIR/decision_forge_v2/.env" "$PROJECTS_DIR/ai-brand-studio/.env" "$HOME/.env"; do
    if [[ -f "$env_file" ]]; then
      api_key=$(grep "^OPENROUTER_API_KEY=" "$env_file" 2>/dev/null | cut -d'=' -f2 | tr -d '"' | tr -d "'")
      [[ -n "$api_key" ]] && break
    fi
  done

  if [[ -z "$api_key" ]]; then
    printf "  ${R}No OPENROUTER_API_KEY found${N}\n"
    return 1
  fi

  local prompt="/no_think
You are analyzing lessons learned and common pitfalls extracted from CLAUDE.md files and memory files across ${project_count} software projects.

## Project Lessons
${all_lessons}
${memory_lessons}

## Currently in Global CLAUDE.md
${global_lessons}

Your task:
1. IDENTIFY cross-cutting patterns — lessons that appear in 2+ projects or apply universally
2. FLAG lessons that are NOT yet in the global CLAUDE.md but should be
3. DEDUPLICATE — merge similar lessons into concise rules
4. CATEGORIZE as: [PROMOTE TO GLOBAL] [PROJECT-SPECIFIC] [ALREADY GLOBAL]

Format your response as:

### Promote to Global CLAUDE.md
- [lesson] — appears in: [project1, project2]

### Cross-Cutting Patterns
- [pattern description] — affected projects: [list]

### Project-Specific (leave in place)
- [project]: [lesson summary]

Be concise. Focus on actionable rules, not descriptions."

  local payload
  payload=$(python3 -c "
import json, sys
print(json.dumps({
    'model': 'qwen/qwen3-32b',
    'messages': [{'role': 'user', 'content': sys.argv[1]}],
    'max_tokens': 2000,
    'temperature': 0.3
}))
" "$prompt")

  local response
  response=$(curl -s -X POST "https://openrouter.ai/api/v1/chat/completions" \
    -H "Authorization: Bearer $api_key" \
    -H "Content-Type: application/json" \
    -d "$payload" 2>/dev/null)

  local content
  content=$(echo "$response" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(data['choices'][0]['message']['content'])
except Exception as e:
    print(f'Error parsing response: {e}')
" 2>/dev/null)

  if [[ -n "$content" ]]; then
    printf "\n"
    echo "$content" | while IFS= read -r line; do
      if [[ "$line" =~ ^###\  ]]; then
        printf "  ${B}${C}%s${N}\n" "$line"
      elif [[ "$line" =~ ^-\  ]]; then
        printf "  %s\n" "$line"
      elif [[ -n "$line" ]]; then
        printf "  ${D}%s${N}\n" "$line"
      fi
    done
    printf "\n  ${D}Review above and add relevant items to ~/.claude/CLAUDE.md${N}\n"
  else
    printf "  ${R}Empty response from AI${N}\n"
  fi
}

# ============================================================
# TYPOGRAPHY — scan for typography quality issues
# ============================================================
cmd_typography() {
  section "Typography Audit"
  printf "  ${D}Scanning CSS + components across all projects...${N}\n\n"

  local total_issues=0

  for proj_dir in "$PROJECTS_DIR"/*/; do
    [[ -d "$proj_dir" ]] || continue
    local proj
    proj=$(basename "$proj_dir")

    # Only scan projects with CSS or component files
    local has_css=false
    [[ -d "$proj_dir/assets/css" ]] && has_css=true
    [[ -d "$proj_dir/lib" ]] && has_css=true
    [[ -d "$proj_dir/src" ]] && has_css=true
    $has_css || continue

    local issues=()
    local issue_count=0

    # ── 1. Arbitrary pixel font sizes in CSS ──
    local px_sizes=()
    if [[ -d "$proj_dir/assets/css" ]]; then
      while IFS= read -r match; do
        [[ -n "$match" ]] && px_sizes+=("$match")
      done < <(grep -rhoP 'font-size:\s*\K\d+px' "$proj_dir/assets/css/" 2>/dev/null | sort -u || true)
    fi

    # Also check for arbitrary Tailwind text-[Npx] in templates
    local tw_arbitrary=()
    for search_dir in "$proj_dir/lib" "$proj_dir/src"; do
      [[ -d "$search_dir" ]] || continue
      while IFS= read -r match; do
        [[ -n "$match" ]] && tw_arbitrary+=("$match")
      done < <(grep -rhoP 'text-\[\d+px\]' "$search_dir/" 2>/dev/null | sort -u || true)
    done

    if (( ${#px_sizes[@]} > 0 )) || (( ${#tw_arbitrary[@]} > 0 )); then
      local all_px="${px_sizes[*]} ${tw_arbitrary[*]}"
      all_px=$(echo "$all_px" | tr ' ' '\n' | sort -u | tr '\n' ' ')
      issues+=("${R}●${N} Arbitrary pixel sizes: ${Y}${all_px}${N}")
      issue_count=$((issue_count + 1))
    fi

    # ── 2. Count distinct font-size values (too many = no scale) ──
    local distinct_sizes=0
    if [[ -d "$proj_dir/assets/css" ]]; then
      distinct_sizes=$(grep -rhoP 'font-size:\s*\K[^;]+' "$proj_dir/assets/css/" 2>/dev/null | sed 's/\s*!important//' | sort -u | wc -l || true)
    fi
    if (( distinct_sizes > 6 )); then
      issues+=("${R}●${N} Too many distinct sizes: ${Y}${distinct_sizes}${N} (>6 suggests no type scale)")
      issue_count=$((issue_count + 1))
    fi

    # ── 3. Missing responsive text ──
    local has_responsive=false
    # Check for Tailwind responsive text classes in templates
    for search_dir in "$proj_dir/lib" "$proj_dir/src"; do
      [[ -d "$search_dir" ]] || continue
      if grep -rqP '(sm|md|lg):text-' "$search_dir/" 2>/dev/null; then
        has_responsive=true
        break
      fi
    done
    # Check for @media with font-size in CSS
    if ! $has_responsive && [[ -d "$proj_dir/assets/css" ]]; then
      if grep -rqP '@media.*\{[^}]*font-size' "$proj_dir/assets/css/" 2>/dev/null; then
        has_responsive=true
      fi
      # Check for responsive CSS var like --phi-base
      if grep -rqP '--.*base.*:.*@media|@media.*--.*base' "$proj_dir/assets/css/" 2>/dev/null; then
        has_responsive=true
      fi
      # Check for @container or responsive type tokens
      if grep -rqP 'font-size:.*clamp\(' "$proj_dir/assets/css/" 2>/dev/null; then
        has_responsive=true
      fi
    fi
    if ! $has_responsive; then
      issues+=("${Y}●${N} No responsive text scaling detected")
      issue_count=$((issue_count + 1))
    fi

    # ── 4. No :root type scale vars ──
    local has_type_scale=false
    if [[ -d "$proj_dir/assets" ]]; then
      # Look for type scale CSS variables (phi, text, font, type, step)
      if grep -rqP ':root\s*\{[^}]*(--phi|--text-|--font-size-|--type-|--step-)' "$proj_dir/assets/" 2>/dev/null; then
        has_type_scale=true
      fi
      # Also check vendor dir (graybeam-ui provides the scale)
      if [[ -d "$proj_dir/assets/vendor/graybeam-ui" ]]; then
        if grep -rqP '(--phi|--text-|--font-size-|--type-|--step-)' "$proj_dir/assets/vendor/graybeam-ui/" 2>/dev/null; then
          has_type_scale=true
        fi
      fi
    fi
    if ! $has_type_scale; then
      issues+=("${Y}●${N} No :root type scale variables")
      issue_count=$((issue_count + 1))
    fi

    # ── 5. Body text < 16px ──
    local body_size=""
    if [[ -d "$proj_dir/assets/css" ]]; then
      # Check for body { font-size: Npx } or html { font-size: Npx }
      body_size=$(grep -rhoP '(?:body|html)\s*\{[^}]*font-size:\s*\K\d+' "$proj_dir/assets/css/" 2>/dev/null | head -1 || true)
      # Also check :root font-size
      if [[ -z "$body_size" ]]; then
        body_size=$(grep -rhoP ':root\s*\{[^}]*font-size:\s*\K\d+' "$proj_dir/assets/css/" 2>/dev/null | head -1 || true)
      fi
    fi
    if [[ -n "$body_size" ]] && (( body_size < 16 )); then
      issues+=("${R}●${N} Body text undersized: ${Y}${body_size}px${N} (< 16px)")
      issue_count=$((issue_count + 1))
    fi

    # ── Report for this project ──
    if (( issue_count > 0 )); then
      printf "  ${B}%-24s${N} ${R}%d issue(s)${N}\n" "$proj" "$issue_count"
      for issue in "${issues[@]}"; do
        printf "    %b\n" "$issue"
      done
      printf "\n"
      total_issues=$((total_issues + issue_count))
    else
      printf "  ${B}%-24s${N} ${G}clean${N}\n" "$proj"
    fi
  done

  # ── Summary ──
  section "Summary"
  if (( total_issues == 0 )); then
    printf "  ${G}All projects pass typography audit.${N}\n"
  else
    printf "  ${Y}%d total issue(s) across projects.${N}\n" "$total_issues"
    printf "  ${D}Fix with: /phi-type (per project)${N}\n"
  fi
}

# ============================================================
# DISPATCH
# ============================================================
case "$CMD" in
  audit)      cmd_audit ;;
  gaps)       cmd_gaps ;;
  sync)       cmd_sync "$@" ;;
  typography) cmd_typography ;;
  *)
    echo "trimtab steer — manage trim tab infrastructure"
    echo ""
    echo "Usage: trimtab steer [command]"
    echo ""
    echo "Commands:"
    echo "  audit       Show trim tab infrastructure across all projects (default)"
    echo "  gaps        Show projects missing key infrastructure"
    echo "  sync        Extract and propagate lessons across projects (--ai for analysis)"
    echo "  typography  Scan for typography quality issues across all projects"
    ;;
esac
